A brief note about coding conventions:

Generally, variable, function and class names are camel case. An exception
is when a function is also a Scheme function with dashes in its name. In that case
the function uses an underscore where a dash occurs in the Scheme name.

Constants are all-caps. Strings are generally "str" if they are for humans; and 'str'
if they're for internal purposes; `str` is used when convenient, as it quite often is.

I use "== null" specifically to test for "nullish" (undefined and null). Be careful
with null since it reports its type as "object" but doesn't do objecty things. Otherwise
I use ===.

"Let" is used rather than "var." Var is forbidden.

I prefer to define functions after they're used. Tell the big picture first, then details.
Often a function will have a broad API, process its arguments and options then call
a mini-me version of itself defined as a local function. This gets the grubby stuff out of
the way and then the function can, for instance, recurse on the simpler API and common
arguments don't need to be passed but instead can be accessed from the containing scope.

I prefer arrow functions for one-liners, regular functions for longer things. for situations
where an own "this" is required, or where a forward reference is needed.

I don't use "const" for things that happen to be const, for instance as loop iterands;
that's just too damn fussy. I use it for things that _should_ be const or _must_ be const.

The current scope is simply a JavaScript object and the scope chain is implemented through its
prototype property. All Scheme code is invoked with "this" as the current scope, and it can
resolve any reference using this[ref]. Nothing could be simpler. Or faster.

Function closures do a lot of the heavy lifting here. For instance, closures are implemented
as a closure that captures then applies the function with the captured scope. Scheme
closures are compiled into JavaScript closures. Since a closure is a JavaScript function,
it can be called as an ordinary JavaScript function whether it is compiled or not. This is
the general case: Scheme functions can call any JavaScript function and JavaScript can call
any Scheme function as long as they invoke it as a method of its scope, which is pretty much
what you'd do anyway.

The compiler compiles a "binder" function that creates local variables containing any outside
values and function definitions since code generated by "new Function" can only see the global
scope. The binder is then invoked so that references can be resolved to things present in
the compilation scope. It returns the function itself.

The compiler uses the builtin function definitions themselves as code-generation templates
in most cases. Special forms (with unevaluated arguments), requires a small code-generatin hook.
To see the compiled code, just invoke String(function), or (String function) in Scheme.
Templates are weaved together using something very much like SSA graphs and the "if" hook
basically generates a "PHI" node. The result is JavaScript in 1-1 correspondence
between Scheme and you'd write it in JavaScript yourself, except for a bunch of assignments
to SSA variables. I trust that the JITs flow analysis will erase those variables. Modern
compiles don't really believe in variables anyway; they believe in values. They wouldn't
even use variables if debuggers didn't need them. But, alas, they do.

I digress. The point is that JITs will go to town on the generated code and since
teams of talented engineers have put man-years of effort into making JavaScript fast,
I stand atop all that work without hardly lifting a finger. It's interesting to note
the degree of correspondence between Scheme's runtime and a JavaScript runtime.
You couldn't design a better Scheme runtime if you tried:

Strings, numbers, booleans and Functions: Check. I threw in BigInt for fun. "Factoral" likes it.

Atoms: Check. They're Symbols (in the ATOMS dictionary).

Scopes: Check. I use the prototype chain and JavaScript resolves it just as it would
a "this" reference. This is something JITs slave over.

Closures: Check. SchemeJS closures are JavaScript closures. Compiled SchemeJS functions
resolve their scope variables as statically-scoped variables in JavaScript.

Cons cells and nil? Those are really the only thing missing and I use JavaScript classes
for those and threw in lazily-evaluated CAR and CDR references with zero overhead on
ordinary lisp cells.

It proved difficult to keep JavaScript objects from sneeking into the Scheme environment
so I invited them in as first'class. SchemeJS is fully Scheme and fully JavaScript. It
even has notations fot array and object literals. Every JavaScript operator and global
symbol is available in SchemeJS. Cons cells are JavaScript-iterables but internally
I generally avoid iterating them because "while (is_cons(obj)) ..." is a lot faster.
But you _can_ iterate over them using "for (let obj of list) ...".
SchemeJS does _not_ see iterables as Cons cells by default. That would be too slow.
But it can create a "list-view" wrapper which lazily invokes the iterator every time
"cdr" is invoked. That works just as well and doesn't tax ordinary list manipulation
primitives.

Scheme atoms are simply Symbols that happen to be in the ATOMS dictionary.

A Scheme instance is the global scope itself. Globally-defined Scheme values and functions
are the values of their atoms, i.e. symbols. JavaScript API methods are string-keyed, and
generally must be invoked as globalScope.apiName(), which, again, is pretty much what you'd
do anyway.