<!DOCTYPE html>
<!--
  SchemeJS: Scheme in JavaScript

  Copyright 2021 Stan Switzer -- (sjswitzer [at] gmail [dot] com)
    This work is licensed under a Creative Commons Attribution-ShareAlike
    4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/
-->
<html>
  <head>
    <title>SchemeJS: Scheme in JavaScript</title>
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="viewport" content="width=device-width">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <meta name="format-detection" content="telephone=no">
    <link rel="apple-touch-icon" href="icon128.png">
    <link rel="manifest" href="manifest.webmanifest">
    <base target="_blank"> <!-- all links open in a new tab/page -->
    <style type="text/css">
      /*
       * If there's a vaguely 60's aesthetic to this UI,
       * consider that it might be deliberate. :)
       */
      html {
        -webkit-text-size-adjust: none
      }

      * { /* input elements lay out bizarrely without this since their borders aren't part of their size */
        box-sizing: border-box;
      }

      body {
        padding: .2em .5em;
        margin: 0em 0em;
        background-color: #f8f8f8;
        text-size-adjust: none;   /* keep mobile browsers from getting sneaky with sizing */
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
      html, table  {
        font: 100% caption, sans-serif;
      }

      /*
       * Initially-hidden help content.
       * Help contains a custom <close-button> and
       * a <div> for help content which is made scrollable.
       */
      div.help {
        padding: 0;
        background-color: #e8e8e8;
        position: absolute;
        display: none;
        top: 10%;
        left: 45%;
        right: .5em;
        bottom: .5em;
        border: .15em solid black;
        border-radius: .5em;
        overflow: hidden;  /* so that scrolled text stays bounded to this box */
      }
      div.help  {
        padding: 0 1em;
      }
      div.help > .top {
        margin: 0 0;
        padding: 0 1em .5em 1em;
        border-bottom: .05em solid black;
      }
      div.help > close-button {
        z-index: 1;
        color: #0005;  /* rather transparent black */
        font-size: 150%;
        --close-button-x-thick: 35%;
        position: absolute;
        top: .3em;
        right: .3em;
        transition: .25s;
      }
      div.help > close-button:hover {
        font-size: 160%;
        color: black;
      }
      div.help > .help-content {
        overflow-y: auto;
        height: 100%;
      }

      .help dl,
      .help dl dt,
      .help dl dd {
        display: block;
        /*
         * "overflow:auto" creates a "block formatting context" while "dislpay:block" does not!
         * I *think* "contain: paint" is more sensible, though, but only seems to work in Chrome.
         * Look up "CSS block formatting context." It's wild!
         * The block formatting context determines the box that "float" items float within.
         */
        overflow: auto;
        contain: paint;
      }
      .help dl {
        margin: .25em 0 .25em 0;
      }
      .help dl dt {
        float: left;
        clear: right;
        margin-inline-end: 1ch;
      }
      .help dl dd {
        float: right;
        margin-inline-start: unset;
        --definition-margin: 15ch;
        --definition-percent: 80%;
        width: max(var(--definition-percent), calc(100% - var(--definition-margin)));
      }
      .help dl dd,
      .help dl dt {
        padding-top: .5em;
      }
      .help dl .heading {
        font-weight: bold;
        font-style: normal !important;
      }
      .help dd p {
        margin: .5em 0 .5em 0;
      }

      .help dl p.impl,
      .help dl p.value {
        color: #555;
      }

      .help .impl:before { content: "Impl: " }
      .help .value:before { content: "Value: " }
      .help .js-names:before { content: "JavaScript: " }
      .help .js-name { padding-right: .5em; }
      .help .impl, .help .value, .help .js-names { display: none }
      div[data-show-impl="true"] .impl, div[data-show-impl="true"] .value { display: block; }
      .help .impl.impl-always { display: block !important }
      div[data-show-javascript="true"] .js-names { display: block; }

      dl#helpgroup-js-op dd .tbd {
        display: none;
      }
      dl#helpgroup-js-op dd .impl {
        display: inline !important;
      }

      #helpgroup-imported dl {
        display: block;
      }
      #helpgroup-imported dt {
        display: span;
        font-style: italic;
      }
      #helpgroup-imported dd {
        display: none;
      }

      .help .example {
        font-style: italic;
      }

      .help .definitions dd {
        font-style: italic;
      }
      .help .definitions dd p {
        font-style: normal;
      }

      #help-details dl dd {
        --definition-margin: 5ch;
      }

      .help ul {
        padding-left: 1.25em;
      }
      .help ul > li {
        margin: .5em;
      }

      code {
        font-style: italic;
        font-family: caption, sans-serif;
      }

      /*
       * Makes a <span> into a "button"
       */
      span.button {
        display: inline-block;
        cursor: pointer;
        padding: .2em .6em;
        background: #44f;
        border-radius: .5em;
        color: white;
      }
      span.button:hover {
        background: #0000dd;
      }
      span.button:active {
        background: #0000cc;
      }
      span.padded-button {
        padding: .2em 1.5ch;
      }

      /* greasy way to make a text-delete button in the input box */
      .clear-text-button {
        position: relative;
        width: 0;
      }
      .clear-text-button > close-button {
        position: absolute;
        bottom: .15em;
        left: -2em;
        color: white;
        --close-button-box-color: #8e8d92;
        --close-button-box-radius: 50%;
        --close-button-x-thick: 25%;
        --close-button-x-size: 55%;
        padding: .05em .4em;
      }

      /* Looks like a link but is actually a "button" */
      span.linklike {
        color: #00d;
        cursor: pointer;
        text-decoration: underline;
      }

      #container {
        display: flex;
        flex-flow: column nowrap;
        overflow: hidden;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: 0;
        padding: .25em .25em .25em .25em;
      }

      #header {
        display: flex;
        flex-flow: row nowrap;
        flex: 0 10 auto;
        width: 100%;
        font-size: 160%;
      }

      #header #title {
        flex: 1 0 auto;
        align-self: flex-end;
      }
      #lambda {
        font-size: 150%;
        margin-right: .15em;
      }

      #header #about {
        flex: 0 0 auto;
      }

      #output, #input { font: 90% Lucida Console, Monaco, Consolas, Courier New, monospace; }

      /* Mobile tweeks; unnecessary CSS selectors to increase match priority */
      @media (hover: none) {
        html body #input {
          font-size: 110%;  
          flex-basis: 4em;
        }
        html body #header {
            font-size: 120%;
        }
      }
      @media (hover: none) and (orientation:portrait) {
        html body #header {
          font-size: 100%;
        }
        html body #input {
          flex-basis: 6em;
        }
        html body .help {
          left: 20%;
        }
      }
      @media not all and (hover: none) {
        body #about { font-size: 80%; }
      }

      #output {
        /* https://geon.github.io/programming/2016/02/24/flexbox-full-page-web-app-layout */
        flex: 1 1 25em;
        overflow: scroll;
        justify-content: flex-end;
        margin-top: 0.1em;
        padding: .15em .15em .15em .15em;
        width: 100%;
        background-color: #ccc;
        border: .1em solid;
        border-radius: .5em;
      }
      #output .input-box, #output .result-box, #output .print-box, #output .error-box {
        position: relative;  /* so that the "tag"" can be positioned absolutely */
        justify-self: end;
        margin-top: 0.25em;
        border: .1em solid;
        border-radius: .5em;
      }
      #output .tag {
        position: absolute;  /* parent div must be position: relative */
        opacity: .5;
        top: 0;
        right: 0;
        margin: 0.3em 0.3em 0 0;
        padding: 0.1em 0.25em 0.1em 0.25em;
        font-size: 90%;
        border: .1em solid;
        border-radius: .5em;
        background-color: #ddd;
      }
      #output .input-scroller, #output .result-scroller, #output .print-scroller {
        overflow: scroll;
        min-height: 2em;
      }
      #output .result-scroller {  max-height: 20em; }
      #output .print-scroller {  max-height: 100em; }
      #output .result-scroller { padding: .5em .5em .5em .5em }
      #output .error-box { padding: .5em .5em .5em .5em }
      #output .input-scroller { padding: 0 0 .5em 0 }
      #output .input-scroller .text { margin: 0 .5em 0 .5em }
      #output .input-scroller .text:first-child { margin-top: .5em }
      #output { background-color: #eeeeee }
      #output .input-box { background-color: #ffffff }
      #output .result-box { margin-left: 1em; background-color: #f8f8f8 }
      #output .error-box { margin-left: 1em; background-color: #ffbbbb }
      #output .print-box { margin-left: 1em; background-color: #ffffcc }
      #output .load-path {
        margin-bottom: .5em;
        padding: .25em;
        background-color: #d6d6fd;
        border-radius: .5em .5em 0 0;
       }

      /* The input box */
      #input {
        flex: 0 0 6em;
        margin-top: 0.25em;
        padding: .5em .5em .5em .5em;
        width: 100%;
        border: .1em solid;
        border-radius: .5em;
        background-color: #ffffff;
      }
      #input .match-tokens {
        border-radius: .5em;
      }
      #input .error-tokens {
        background-color: rgb(252, 124, 124);
      }

      /* canvas support */
      .canvas-frame { user-select: none }
      .canvas-frame .title-bar { font: 90% Lucida Console, Monaco, Consolas, Courier New, monospace; }
      .canvas-frame .title-bar close-button {
        --close-button-box-color: #f77;
        --close-button-x-thick: 25%;
        --close-button-x-size: 65%;
        color: white;
        vertical-align: -20%;
        transition: .5s;
        transition-property: --close-button-box-color;
        margin-right: 1ch;
      }
      .canvas-frame .title-bar close-button:hover {
        --close-button-box-color: #f00;
      }
      .canvas-frame {
        display: flex;
        flex-flow: column nowrap;
        position: absolute;
        background-color: #ddd;
        border: .1em solid;
        border-radius: .5em;
        padding: 5px;
      }
      .drawing-canvas {
        background-color: white;
      }

      .microphone-control {
        user-select: none;
        margin-top: .1em;
        margin-left: .1em;
        align-self: flex-start;
      }
      .microphone-control label { position:relative; cursor: pointer; bottom: .1em }
      .microphone-control .mute-toggle {
        position: absolute;
        opacity: 0;
      }
      .microphone-control .muted {
        display: inline-block; padding: 0;
        font-size: 200%; height: 100%;
        position: absolute; margin-top: -.2em; left: -.1em;
        color: #f88;
      }
      .microphone-control .muted { display: none }
      .microphone-control .mute-toggle:checked ~ .muted {
        display: inline-block; padding: 0;
        font-size: 200%; height: 100%;
        position: absolute; margin-top: -.2em; left: -.1em;
      }
    </style>
  </head>
  <body id="body">
    <div id="container">
      <div id="header">
        <div id="title"><span id="lambda">&lambda;</span> SchemeJS: Scheme in JavaScript</div>
        <div id="about">
          <span class="button" onclick="showHelp('help-about')"> ? </span>
        </div>
      </div>
      <div id="output"></div>
      <div id="input" spellcheck="false" autocomplete="off" spellcheck="false" autocorrect="off"
          autocapitalize="none"></div>
    </div>
    <input type="file" style="display:none" id="load-file-dialog" accept=".scm">
    <div style="display: none">
      <div id="user-media-template" class="microphone-control" onmousedown="event.stopPropagation()">
        <label>
          <input type="checkbox" class="mute-toggle">
            &#x1F3A4
            <div class="muted">&#x29B8;</div>
        </label>
        <input class="volume" type="range" value="100" min="0" max="100" step="5">
      </div>
    </div>
    <div class="help" id="help-about">
      <close-button onclick="showHelp(null)"></close-button>
      <div class="help-content">
        <h2> SchemeJS: Scheme in JavaScript </h2>
        <p> JavaScript has dynamic typing, functions, closures, and a JIT with
            a small army of crack programmers optimizing its performance.
            It’s an ideal runtime for Scheme.
            All it lacks is cons cells, an s-expression parser/printer,
            eval/apply, and a handful of Lisp primitives.
        <p> Oh, and a compiler and JIT that compiles Scheme down to perfectly normal
            JavaScript functions that JavaScript JITs can go to town on.
        <p> SchemeJS fills that gap.
        <p> It’s hard to keep JavaScript objects from sneaking into the
            SchemeJS world, so I decided to invite them in as first-class.
            SchemeJS is fully Scheme <i>and</i> fully JavaScript.
        <p> This implementation aims for broad compatibility with SIOD, but inevitably,
            and in the grand tradition of lisp implementations, introduces a new dialect.
            Which is a sin but not a crime.
        <p> Run a demo by typing <code>(load "demo.scm")</code>
          or <code>(load "gfxdemo.scm")</code>
          or <code>(load "mediademo.scm")</code>.
          <p> Learn about
            <span class="linklike" onclick="showHelp('help-builtin')"">built-in Scheme definitions</span> and
            <span class="linklike" onclick="showHelp('help-details')"">implementation details</span>.
      </div>
    </div>
    <div class="help" id="help-details">
      <close-button onclick="showHelp(null)"></close-button>
      <div class="help-content">
        <h2> Implementation Details </h2>
        <p>
        <h3> Key Features </h3>
        <h4> JavaScript Integration and Interoperability</h4>
        <p> SchemeJS and JavaScript have full and fluent access to each other's objects.
            SchemeJS can call invoke any JavaScript function and every SchemeJS
            function is a JavaScript function, <i>whether it is compiled or not</i>.
        <p> Syntax for JavaScript Object and Array literals.
        <p> Core SchemeJS primitives are implemented directly on fundamental
            JavaScript primitives such as function closures and prototype resolution.
            These are the things that JavaScript JITs optimize most thouroughly.
        <h4> Iterable-Aware </h4>
        <p> SchemeJS lists are iterable in JavaScript and JavaScript iterables are
            Scheme lists.
            SchemeJS functions that operate on lists also operate on JavaScript
            iterable such as Arrays.
        <h4> N-ary Comparisons </h4>
        <p> Comparison functions such as "<" can be applied to arbitrarily many arguments. In this case
            it means that each argument is less than the previous. Evaluation ends as soon as
            the comparison fails.
        <h4> Partial Function Application </h4>
        <p> Functions, whether user-defined, compiled or implemented in JavaScript, when
            invoked with fewer than their required number of arguments, result
            in a <i>closure</i> that binds the given arguments.
            For instance, <code>(+ 5)</code> results in a function (closure) that
            adds 5 to its argument(s).
        <p> Because the expression <code>(< 10)</code> evaluates to a function that's
            true if 10 is less than its argument, the expression
            <code>(filter (< 10) list)</code> returns a new list with elements from <code>list</code>
            that are ten or greater. (Seems backwards, perhaps, but that's Scheme for ya.)
        <h4> Generalized Special Forms </h4> 
        <p> Users can define "special forms" that take a specified number of evaluated parameters;
            the rest are unevaluated.
            In <code>(\# 2 (a1 a3 a3 a5) forms...)</code>, <i>a1</i> and <i>a2</i> are evaluated and the rest are not.
        <h4> Optional Parameters </h4>
        <p> A function defined as <code>(def (fn p1 (p2 expr) (p3 expr) ) form ...)</code>
            has optional parameters <code>p2</code> and <code>p3</code> with default values
            supplied by the expressions that follow them. The expressions are evaluated only
            if the parameter is absent.
        <h4> Rest Parameters </h4>
        <p> A function defined as <code>(def (fn p1 p2 ...p3) form ...)</code> takes two
            normal parameters (<i>p1</i> and <i>p2</i>) and receives a third parameter <i>p3</i>,
            that recieves a list of the remaining arguments.
        <p> Similarly, a lambda of the form <code>(&lambda; (p1 p2 ...p3) form ...)</code> has a
            rest parameter <i>p3</i>.
        <h4> Predicates as Conditionals </h4>
        <p> Predicates such as <code>number?</code> can be used to test a value's type
            and return a boolean, or as conditionals themselves.
        <h4> Lazy Lists and Map Functions </h4>
        <p> JavaScript iterators are seen as lazy lists cells that don't fetch
            the next object until <i>cdr</i> is invoked.
        <p> Lazy "map" is the same, but in addition the mapping function is not applied
            until <i>car</i> is invoked on the mapped list.
        <h4> Compiler </h4>
        <p> A compiler (a "transpiler," technically, but that sounds silly)
            that transforms Scheme into perfectly normal JavaScript that the
            JIT can go to town on.
        <p> An optional JIT that kicks in after a client-selectable number of invocations
            of a function. Because a JIT necessarily <i>binds</i> the current definitions
            of functions referenced in the compiled code, JIT-compiled code contains
            a <i>guard</i> that ensures those bindings have not changed and bails to the
            interpreter if they have. The function is then elligible to be JITted again
            if invoked sufficiently often.
        <h4> Easly Embedded </h4>
        <p> SchemeJS is a JavaScript module designed to be easily embedded into other applications.
            Scheme JS can run in any web page (in a sufficiently modern browser; even on mobile devices)
            and can do anything JavaScript can do with as few as a half dozen lines of code to import it.
        <p> It comes with a Node.js-based CLI/REPL and this web-based REPL but
            they're just simple embeddings of the SchemeJS runtime.
        <p> SchemeJS has <i>no dependencies</i> beyond a modern JavaScript runtime.
        <h4> Unicode </h4>
        <p> SchemeJS identifiers can use any Unicode "alphabetic" characters (including ideographs).
            People should be able to program in their own languages.
        <h3> Sundry </h3>
        <p> <span class="linklike" onclick="runUnitTests()">Run unit tests</span>; results
            display in the browser console. This Web REPL curently configures
            the runtime to log compiled code to the console.
            You can also see the compiled code of a funtion by typing
            <code>(println (String fn))</code>.
        <p> Copyright &copy; 2021, Stan Switzer &mdash; (sjswitzer [at] gmail [dot] com)
        <div style="width: 100%">
          This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            Creative Commons Attribution-ShareAlike 4.0 International License</a>.
          <br> Find source on
          <a href="https://github.com/sjswitzer/SchemeJS">GitHub</a>
          <p></p>
        </div>
      </div>
    </div>
    <div class="help" id="help-builtin">
      <close-button onclick="showHelp(null)"></close-button>
      <div class= "top"">
        <h2 style="margin-bottom:.25em"> Built-In Functions and Constants </h2>
        <input type="checkbox" name="impl"
          onchange="parentElement.parentElement.setAttribute('data-show-impl', String(event.currentTarget.checked))">
        <label for="javascript">Implementations</label> &nbsp;
        <input type="checkbox" name="javascript"
          onchange="parentElement.parentElement.setAttribute('data-show-javascript', String(event.currentTarget.checked))">
        <label for="javascript">JavaScript API</label>
      </div>
      <div class="help-content">
        <h3> Core Definitions</h3>
        <dl class="definitions" id="helpgroup-main">
          <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Mathematical Operations and Constants</h3>
        <dl class="definitions" id="helpgroup-math">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Bitwise Operations </h3>
        <p> Other bitwise operations are listed avove under N-Ary Operations.
        <dl class="definitions" id="helpgroup-bitwise-op">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Comparison Operations </h3>
        <p> These operations take an arbitrary number of arguments and return false,
            ending evaluation, as soon as the relation fails to hold between successive elements.
        <dl class="definitions" id="helpgroup-compare">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Logical Operations </h3>
        <dl class="definitions" id="helpgroup-logical">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Control Flow Operations </h3>
        <dl class="definitions" id="helpgroup-control-flow">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h2> Predicate Conditional Operations </h2>
        <p> These operations can function as simple predicates, returning <code>true</code> or
            <code>false</code>, or as conditional operations, evaluating the second argument
            if true and the third if false. You were probably going to us it for a condition anyway.
            (Actually, it <i>always</i> evaluates and returns the second or third argument; it's just that
            their default values are <code>true</code> and <code>false</code>.)
        <dl class="definitions" id="helpgroup-pred-op">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Utility </h3>
        <dl class="definitions" id="helpgroup-utility">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> List Operations </h2>
        <dl class="definitions" id="helpgroup-list">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> JavaScript-Related </h2>
        <p> The implementations should explain what they do well enough.
        <dl class="definitions" id="helpgroup-javascript">
          <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Web Graphics </h2>
        <dl class="definitions" id="helpgroup-web-gfx">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Web Graphics Taking Explicit Context </h2>
          <dl class="definitions" id="helpgroup-web-gfx-context">
             <!-- definitions inserted here when SchemeJS module is loaded -->
          </dl>
          <h3> Uncategorized </h2>
        <dl class="definitions" id="helpgroup-undefined">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Functions and Constants Imported from JavaScript </h2>
        <dl class="definitions" id="helpgroup-imported">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
      </div>
    </div>
    <div class="function-help-definitions" style="display: none !important">
      <!-- These definitions get moved into the help section at startup -->
      <dd id="defn-*e*">
        Euler's constant and the base of natural logarithms
      </dd>
      <dd id="defn-*ln10*">
        Natural logarithm of 10
      <dd id="defn-*log10e*">
        Base-10 logarithm of Euler's constant
      </dd>
      <dd id="defn-*log2e*">
        Base-2 logarithm of Euler's constant
      </dd>
      <dd id="defn-*pi*">
        Ratio of the a circle's circumference to its diameter (&pi;)
      <dd id="defn-*sqrt1_2*">
        Square root of 1/2
      </dd>
      <dd id="defn-*sqrt2*">
        Square root of 2
      </dd>
      <dd id="defn-*ln2*">
        Natural logarithm of 2
      <dd id="defn-abs">
        (abs x)
        <p> Absolute value of <i>x</i>; <i>x</i> can be a number or a bigint.
      </dd>
      <dd id="defn-acos">
        (acos x)
        <p> Arccosine of x in radians.
      </dd>
      <dd id="defn-acosh">
        (acosh x)
        <p> Hyperbolic arccosine of x in radians.
      </dd>
      <dd id="defn-asin">
        (asin x)
        <p> Arcsine of x in radians.
      </dd>
      <dd id="defn-asinh">
        (asinh x)
        <p> Hyperbolic arcsine of x in radians.
      </dd>
      <dd id="defn-atan">
        (atan x)
        <p> Arctangent of x in radians.
      </dd>
      <dd id="defn-atanh">
        (atanh x)
        <p> Hyperbolic arctangent of x in radians.
      </dd>
      <dd id="defn-atan2">
        (atan2 y x)
        <p> Angle in radians from the positive x axis and the ray to the point (x, y).
            Does not suffer from divide-by-zero issues as <i>tan</i> would.
      </dd>
      <dd id="defn-sqrt">
        (sqrt x)
        <p> Square root of x.
      </dd>
      <dd id="defn-cbrt"><div>
        (cbrt x)
        <p> Cube root of x.
      </dd>
      <dd id="defn-clz32">
        (clz32 x)
        <p> Number of leading zeros in the binary representation of x
            considered as a 32-bit integer.
      </dd>
      <dd id="defn-cos">
        (cos x)
        <p> Cosine of x in radians.
      </dd>
      <dd id="defn-cosh">
        (cosh x)
        <p> Hyperbolic cosine of x in radians.
      </dd>
      <dd id="defn-expm1">
        (expm1 x)
        <p> The value <code>(- (exp x) 1)</code>, avoiding numerical anomalies.
      </dd>
      <dd id="defn-log1p">
        (log1p x)
        <p> The natural logarithm of <code>x+1</code>, avoiding numerical anomalies.
      </dd>
      <dd id="defn-exp">
        (exp x)
        <p> Euler's number to the power x.
      </dd>
      <dd id="defn-floor">
        (floor x)
        <p> The largest integer less than or equal to x.
      </dd>
      <dd id="defn-ceil">
        (ceil x)
        <p>The smallest integer greater than or equal to x.
      </dd>
      <dd id="defn-fround">
        (fround x)
        <p> The closest single precision floating point representation of x.
      </dd>
      <dd id="defn-hypot">
        (hypot value ...)
        <p> The square root of the sum of the squares of the arguments.
      </dd>
      <dd id="defn-imul">
        (imul x y)
        <p> Result of the multiplication of x and y considered as 32-bit integers.
      </dd>
      <dd id="defn-log">
        (log x)
        <p> The natural logarithm of x.
      </dd>
      <dd id="defn-log10">
        (log x)
        <p> The base-10 logarithm of x.
      </dd>
    </div>
    <script type="module" src="./CloseButton.mjs"></script>
    <script type="module">
      "use strict";
      import * as SchemeJSWeb from './SchemeJSWeb.mjs';
      const optional = undefined;  // so that optional parameters show up pretty when printed

      const bodyElement = document.getElementById('body');
      const containerElement = document.getElementById('container');
      const inputElement = document.getElementById('input');
      const outputElement = document.getElementById('output');
      const loadFileInputElement = document.getElementById('load-file-dialog');
      const userMediaTemplateElement = document.getElementById("user-media-template");

      const NBSP = '\u00a0', functionStr = "\u03BB";
      let printBoxElement, varNo = 0;

      let traceCompilerCode = false, traceInterpreter = true;
      let globalScope = SchemeJSWeb.createInstance({
        functionStr, readFile, linePrinter, traceCompilerCode, traceInterpreter,
        reportLoadResult, reportLoadInput, reportSchemeError, reportSystemError
      });
      let SCHEME_VERSION = globalScope.VERSION ?? required();
      let SchemeParseError = globalScope.SchemeParseError ?? required();
      let SchemeSyntaxError = globalScope.SchemeSyntaxError ?? required();
      let SchemeParseIncompleteError = globalScope.SchemeParseIncompleteError ?? required();
      let SchemeEvalError = globalScope.SchemeEvalError ?? required();
      let NIL = globalScope.NIL ?? required();
      let BOTTOM = globalScope.BOTTOM; // Can't "require" it because "undefined" is indeed a bottom.
      let string = globalScope.string ?? required();
      let Atom = globalScope.Atom ?? required();
      let newScope = globalScope.newScope ?? required();
      let exportAPI = globalScope.exportAPI ?? required();
      let defineBinding = globalScope.defineBinding ?? required();
      let WS = globalScope.WS ?? required();
      let NL = globalScope.NL ?? required();
      function required() { throw "required" }

      let loadAtom = Atom("load");
      let originalLoad= globalScope[loadAtom] ?? required();
      globalScope[loadAtom] = load;

      defineGraphicsFunctions();

      buildBuiltinHelp(globalScope);

      // The idea here is to let the handleInput exacute after the keypress has been
      // completely processed. "oninput" is nice, but doesn't indicate the "Enter" key.
      inputElement.onkeydown = event => setTimeout(() => handleInput(event.key === 'Enter'), 0);

      // TODO: I'm just looking for selection changes; there's probably a better way
      inputElement.onmousedown = event => setTimeout(() => handleInput(), 0);
      
      inputElement.contentEditable = 'true';
      inputElement.focus();

      // For "load" and "require"
      let capturedInput, loadPath, loadLine, loadLineCount, loadAsyncContent;

      function load(path = optional, noEval = false) {
        if (path)
          doXHRLoad();
        else
          doFileLoad();
        return BOTTOM;
        async function doXHRLoad() {
          let xhr = new Promise((resolve, reject) => {
            let request = new XMLHttpRequest();
            // Bypass the cache.
            //   https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#bypassing_the_cache
            let reqPath = path + ((/\?/).test(path) ? "&" : "?") + (new Date()).getTime()
            request.onload = _ => {
              if (request.status === 200)
                resolve(request.responseText);
              else
                reject(new Error(`Load ${path}, status ${request.status}`));
            };
            request.onerror = _ => {
              // Try again without the query param (this is for PWAs that may have cached the resource for offline)
              request = new XMLHttpRequest();
              request.onload = _ => {
                if (request.status === 200)
                  resolve(request.responseText);
                else
                  reject(new Error(`Load ${path}, status ${request.status}`));
              }
              request.onerror = event => reject(new Error(`XMLHttpRequest error ${String(event)}`));
              let async = true;
              request.open('GET', reqPath, async);
              request.send(null);
            }
            let async = true;
            request.open('GET', reqPath, async);
            request.send(null);
          });
          try {
            let content = await xhr;
            invokeLoadWithPathAndContent(path, content);
          } catch (error) {
            showError(error);
          }
        }
        function doFileLoad() {
            loadFileInputElement.onchange =  function handleFileLoad(event) {
              let fileList = this.files, file = fileList[0];
              loadContent(file);
              async function loadContent(file) {
                let path = file.name;
                let content = await(file.text());
                invokeLoadWithPathAndContent(path, content);
              }
            };
            loadFileInputElement.click();
        }
        function invokeLoadWithPathAndContent(path, content) {
          let saveLoadAsyncContent = loadAsyncContent, savePath = loadPath, saveLine = loadLine, saveLoadLineCount = loadLineCount;
          loadAsyncContent = content;
          loadPath = path;
          loadLine = 0;
          loadLineCount = 0;
          let res;
          try {
            res = originalLoad.call(globalScope, path, noEval);
          } catch (error) {
            showError(error);
          } finally {
            loadAsyncContent = saveLoadAsyncContent;
            loadPath = savePath;
            loadLine = saveLine;
            loadLineCount = saveLoadLineCount;
          }
          return res;
        }
      }

      function readFile(path) {
        let content = loadAsyncContent;
        if (content === undefined) {
          let request = new XMLHttpRequest();
          let reqPath = path + ((/\?/).test(path) ? "&" : "?") + (new Date()).getTime()
          request.onerror = event => reject(new Error(`XMLHttpRequest error ${String(event)}`));
          let async = false;
          request.open('GET', reqPath, async);
          request.send(null);
          if (request.status !== 200)
            throw new Error(`Load ${path}, status ${request.status}`);
          content = request.responseText;
        }
        capturedInput = '';
        return captureInput(loadAsyncContent);
        return null;
        function* captureInput(source) {
          for (let ch of source) {
            // Eat up initial whitespace and newlines so the reported line
            // isn't at the head of whitespace
            if (capturedInput === '') {
              if (ch === '\n') {
                loadLineCount += 1;
                continue;
              }
              if (WS[ch])
                continue;
              loadLine = loadLineCount+1;
            }
            capturedInput += ch;
            if (NL[ch])
              loadLineCount += 1;
            yield ch;
          }
        }
      }

      function reportLoadInput(expr) {
        varNo += 1;
        showInput(capturedInput, loadPath, loadLine, expr, varNo);
        capturedInput = '';
      }

      function reportLoadResult(result, expr) {
        showResult(result, varNo);
      }

      function reportSchemeError(error, expr) {
        showInput(capturedInput, loadPath, loadLine);
        capturedInput = '';
        showError(error);
      }

      function reportSystemError(error, expr) {
        showInput(capturedInput, loadPath, loadLine);
        capturedInput = '';
        showError(error);
      }

      let helpStack = [];

      function showHelp(id) {
        let elts = document.querySelectorAll('div.help');
        for (let e of elts)
          e.style.display = ''; // back to inherited 'none'
        if (!id) {
          helpStack.pop();
          if (helpStack.length > 0)
            helpStack[helpStack.length-1].style.display = 'block';
          return;
        }
        id = id.split("#");
        let frag = id[1];
        id = id[0];
        let helpElement = document.getElementById(id);
        if (helpElement) {
          helpStack.push(helpElement);
          helpElement.style.display = 'block'; // inherits 'none' from "help" class
          let contentElement = helpElement.querySelector('div');
          if (contentElement) {
            contentElement.scrollTop = 0;
            if (frag) {
              let element = contentElement.querySelector(`#${frag}`);
              if (element)
                element.scrollIntoView(true);
            }
          }
        }
      }

      function buildBuiltinHelp(globalScope) {
        const string = globalScope.string;
        let helpInfo = globalScope._helpInfo_, groups = {}, jsAPI = helpInfo.jsAPI;
        let getFunctionInfo = globalScope.getFunctionInfo;
        let jsAPIMap = new Map();
        // Invert the JS API names
        for (let jsName in jsAPI)
          jsAPIMap.set(jsAPI[jsName], jsName);
        // Invert by group on atom sort key
        for (let atom of Object.getOwnPropertySymbols(helpInfo)) {
          let info = helpInfo[atom], helpGroup = info.group;
          let symTab = groups[helpGroup];
          if (!symTab)
            symTab = groups[helpGroup] = [];
          symTab.push({key: keyFor(atom), ...info});
        }
        for (let helpGroup in groups) {
          let symtab = groups[helpGroup];
          symtab.sort((a,b) => a.key < b.key ? -1 : 1);
          let helpElement = document.getElementById(`helpgroup-${helpGroup}`);
          if (!helpElement) {
            console.error("Missing help group", helpGroup);
            continue;
          }
          for (let info of symtab) {
            let atoms = info.atoms;
            let atom = atoms[0];
            let value = info.value;
            let jsName = jsAPIMap.get(value);
            if (helpGroup === "imported") {
              let atomDesc = atom.description, anchor = createElement('a', null, atomDesc);
              let href = `https://developer.mozilla.org/docs/Web/API/${atomDesc}`;
              if (atomDesc.includes('-')) {  // reassigned names, like Object-getOwnPropertyNames
                let parts = atomDesc.split('-');
                href = `https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/${parts[0]}/${parts[1]}`;
              }
              anchor.setAttribute('href', href);
              let dt = createElement('dt');
              dt.appendChild(anchor);
              helpElement.appendChild(dt);
            } else {
              let dt = createElement('dt', null, atom.description);
              helpElement.appendChild(dt);
              let dd = createElement('dd');
              if (info.sample)
                dd.textContent = info.sample;
              if (info.blurb)
                dd.appendChild(createElement('p', null, info.blurb));
              if (!info.sample && !info.blurb) {
                let elementId = "defn-" + atom.description;
                let ddElement = document.getElementById(elementId);
                if (ddElement)
                  dd = ddElement;
                else {
                  let gfxApi = info.gfxApi;
                  if (gfxApi) {
                    let anchor = createElement('a', 'see-online-docs');
                    anchor.setAttribute('href', `https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/${gfxApi}`);
                    anchor.textContent = "See online documentation";
                    dd.appendChild(anchor);
                  } else {
                    dd.appendChild(createElement('span', 'tbd', `TBD defn-${atoms[0].description}`));
                  }
                }
              }
              helpElement.appendChild(dd);
              if (typeof value === 'function') {
                let implStr = info.implStr;
                if (!implStr) implStr = string(value);
                let implElement = createElement('p', 'impl', implStr);
                if (helpGroup === 'javascript' || helpGroup.includes('web-gfx'))
                  implElement.classList.add('impl-always');
                dd.appendChild(implElement);
              } else {
                dd.appendChild(createElement('p', 'value', string(value)));
              }
              if (jsName) {
                let fnInfo = getFunctionInfo(value);
                let requiresScopeStr = fnInfo?.requiresScope ? " (requires scope)" : "";
                let jsNamesElement = createElement('p', 'js-names');
                dd.appendChild(jsNamesElement);
                jsNamesElement.appendChild(createElement('span', 'js-name', jsName + requiresScopeStr));
              }
            }
          }
        }
        function keyFor(atom) {
          let key = atom.description, alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", stripPrefixSyms = "*#!?";
          key = key.toUpperCase();
          // Strip certain special symbols before alpha (mostly for *catch and *throw)
          if (stripPrefixSyms.includes(key[0]) && alpha.includes(key[1]))
            key = key.substr(1);
          // Anything that doesn't begin with an alpha gets sorted to the top (space sorts lowest)
          if (!alpha.includes(key[0]))
            key = ' ' + key;
          return key;
        }
      }

      function createElement(type = 'div', cls, text) {
        let element = document.createElement(type);
        if (cls)
          element.setAttribute('class', cls);
        if (text)
          element.textContent = text;
        return element;
      }

      const LOCAL_STORAGE_KEY = `SchemeJS-${location.pathname}`;
      const appVersion = "1.1";
      let persistedState = {};

      function saveState() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        persistedState.version = appVersion;
        let json = JSON.stringify(wad);
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, json);
          return true;
        }
        catch (_) {
        }
        return false;
      }

      function loadState() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        let json = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!json)
          return false;
        let wad;
        try {
          wad = JSON.parse(json);
        } catch (_) {
          //  ¯\_(ツ)_/¯
        }
        if (typeof wad !== 'object')
          return false;
        let appVer = appVersion.split('.'), saveVer = wad.version.split('.');
        if (!(Number(saveVer[0]) <= Number(appVer[0])))  // handles undefined implicitly
          return false;
        persistedState = wad;
        return true;
      }

      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape')
          showHelp(null);
      });

      function defineGraphicsFunctions() {
        let newCanvasX = 20, newCanvasY = 10;
        let gfxContextAtom = Atom("gfx-context"), drawAtom = Atom("draw");
        let animateAtom = Atom("animate"), clearCanvasAtom = Atom("clear-canvas"), backingBufferAtom = Atom("backing-buffer");;
        let showAtom = Atom("show"), hideAtom = Atom("hide"), clearColorAtom = Atom("clear-color");
        let xAtom = Atom("x"), yAtom = Atom("y"), widthAtom = Atom("width"), heightAtom = Atom("height");
        let userMediaAtom = Atom("user-media");
        globalScope.contextToSchemeWidget = contextToSchemeCanvasWidget;
        let contextToSchemeCanvasWidgetMap = new WeakMap();
        function contextToSchemeCanvasWidget(ctx) { return contextToSchemeCanvasWidgetMap.get(ctx) }

        class SchemeCanvasWidget {
          _canvasFrameElement; _canvasElement; _canvas2dRenderingContext;
          _clearColor; _animate = false; _clearCanvasMode = true;
          _backingBufferWidth = 0; _backingBufferHeight = 0; _backingCanvas; _backing2dRenderingContext;
          _staleImage = false; _forceClear = false;
          _drawTime = Date.now(); _tickCount = 0; _stashX; _stashY;
          _volumeElement; _muteElement;
          _userMedia; _userMediaElement; _userMediaStream; _audioContext;
          _audioAnalyser; _fftSize = 1024 ; _frequencyDataArray = new Uint8Array(1);; _timeDomainDataArray = this._frequencyDataArray;
          constructor(canvasFrameElement, canvasElement) {
            this._canvasFrameElement = canvasFrameElement;
            this._canvasElement = canvasElement;
            this._canvas2dRenderingContext = canvasElement.getContext('2d');
          }
          // Delegate JavaScript API to Scheme API
          get x() { return this[xAtom] }
          set x(value) { this[xAtom] = value }
          get y() { return this[yAtom] }
          set y(value) { this[yAtom] = value }
          get width() { return this[widthAtom] }
          set width(value) { this[widthAtom] = value }
          get height() { return this[heightAtom] }
          set height(value) { this[heightAtom] = value }
          get drawFn() { this[drawAtom] }
          set drawFn(value) { this[drawAtom] = value }
          get animate() { this[animateAtom] }
          set animate(value) { this[animateAtom] = value }
          get animate() { this[animateAtom] }
          set animate(value) { this[animateAtom] = value }
          get clearCanvas() { this[clearCanvasAtom] }
          set clearCanvas(value) { this[clearCanvasAtom] = value }
          get clearColor() { this[clearColorAtom] }
          set clearColor(value) { this[clearColorAtom] = value }
          show(...params) { return this[showAtom](...params) }
          hide() { this[hideAtom]() }
          get canvasElement() { return this._canvasElement }
          get canvasFrame() { return this._canvasFrameElement }
          get canvas2dRenderingContext() { return this._canvas2dRenderingContext }
          backingBuffer(width, height = width) { return this[backingBufferAtom](width, height) }

          // Scheme API
          get [xAtom]() { return parseInt(this._canvasFrameElement.style.left) }
          set [xAtom](x) { this._canvasFrameElement.style.left = x+"px" }
          get [yAtom]() { return parseInt(this._canvasFrameElement.style.top) }
          set [yAtom](y) { this._canvasFrameElement.style.top = y+"px" }
          get [widthAtom]() { return this._canvasElement.width }
          set [widthAtom](width) { this._resizeWithoutSmashingContent(width, this._canvasElement.height) }
          get [heightAtom]() { return this._canvasElement.height }
          set [heightAtom](height) { this._resizeWithoutSmashingContent(this._canvasElement.width, height) }
          get [drawAtom]() { return this._drawFn; }
          set [drawAtom](fn) {
            if (typeof fn !== 'function')
              throw new SchemeEvalError(`[draw] not a function ${string(fn)}`);
            this._drawFn = fn;
            this._staleImage = true;
            window.requestAnimationFrame(
              this._animate ? (_ => this.startAnimation()) : (_ => this._doRedraw()));
          }
          get [animateAtom]() { return this._animate }
          set [animateAtom](value) {
            this._animate = value;
            if (value)
              this.startAnimation();
          }
          get [userMediaAtom]() { return this._userMedia }
          set [userMediaAtom](value) { this._startUserMedia(value) }
          get [clearCanvasAtom]() { return this._clearCanvasMode }
          set [clearCanvasAtom](value) { this._clearCanvasMode = value }
          get [clearColorAtom]() { return this._clearColor }
          set [clearColorAtom](value) { this._clearColor = value; this._forceClear = true; }
          get [Atom('fft-size')]() { return this._fftSize }
          set [Atom('fft-size')](value) { this._fftSize = Math.max(32, Math.min(32768, 2**Math.ceil(Math.log2(value)))) }
          [backingBufferAtom](width, height = width) {
            this._backingBufferWidth = width;
            this._backingBufferHeight = height;
          }
          [showAtom](x = optional, y = optional, width = optional, height = optional) {
            let cfe = this._canvasFrameElement;
            if (x !== undefined) this[xAtom] = x;
            if (y !== undefined) this[yAtom] = y;
            if (width !== undefined) this._canvasElement.width = width;
            if (height !== undefined) this._canvasElement.height = height;
            containerElement.appendChild(cfe);
            if (this._animate)
              this.startAnimation();
            this._setGain();
            return this;
          }
          [hideAtom]() {
            let cfe = this._canvasFrameElement;
            if (cfe.parentNode)
              cfe.parentNode.removeChild(cfe);
            this._setGain();
            return this;
          }
          get [Atom('frequency-domain-data')]() {
            if (!this._audioAnalyser) this._attachAnalyser();
            let audioAnalyser = this._audioAnalyser, fdda = this._frequencyDataArray;
            if (audioAnalyser && fdda.length !== 1)
              audioAnalyser.getByteFrequencyData(fdda);
            return fdda;
          }
          get [Atom('time-domain-data')]() {
            if (!this._audioAnalyser) this._attachAnalyser();
            let audioAnalyser = this._audioAnalyser, tdda = this._timeDomainDataArray;
            if (audioAnalyser && tdda.length !== 1)
              audioAnalyser.getByteTimeDomainData(tdda);
            return tdda;
          }
          // Utility methods
          _clear_canvas() {
            let cxt = this._canvas2dRenderingContext, backing2dRenderingContext = this._backing2dRenderingContext;
            if (backing2dRenderingContext)
              cxt = backing2dRenderingContext;
            cxt.save();
            let clearColor = this._clearColor;
            if (clearColor) {
              cxt.fillStyle = clearColor;
              cxt.fillRect(0, 0, this._width, this._width);
            } else {}
              cxt.clearRect(0, 0, this._width, this._height);
            cxt.restore();
          }
          _attachAnalyser() {
            if (this._audioAnalyser || !this._audioContext || !this._gainNode) return;
            let audioAnalyser = this._audioAnalyser = this._audioContext.createAnalyser();
            audioAnalyser.fftSize = this._fftSize;
            this._gainNode.connect(audioAnalyser);
            this._setGain();
          }
          _setGain() {
            if (!this._gainNode) return;
            let muted = this._muteElement?this._muteElement.checked : false;
            if (muted || !this._canvasFrameElement.parentNode) {
              this._audioContext.suspend();
              this._frequencyDataArray = this._timeDomainDataArray = new Uint8Array(1);
              return;
            }
            else {
              this._audioContext.resume();
            }
            if (this._audioAnalyser && this._frequencyDataArray.length === 1) {
              this._frequencyDataArray = new Uint8Array(this._audioAnalyser.frequencyBinCount);
              this._timeDomainDataArray = new Uint8Array(this._audioAnalyser.fftSize);
            }
            let volume = this._volumeElement ? parseFloat(this._volumeElement.value) / 100 : .5;
            this._gainNode.gain.setValueAtTime(volume, this._audioContext.currentTime);
          }
          _resizeWithoutSmashingContent(newWidth, newHeight) {
            let scratch = createElement('canvas');
            let ctx = this._canvas2dRenderingContext, canvasElement = this._canvasElement;
            let width = canvasElement.width, height = canvasElement.height;
            // Unfortunately, you can't set them together
            scratch.width = width;
            scratch.height = height;
            ctx.drawImage(canvasElement, 0, 0, width, height, 0, 0, width, height);
            canvasElement.width = newWidth;
            canvasElement.height = newHeight;
            ctx.save();
            ctx.resetTransform();
            let clearColor = this._clearColor;
            if (clearColor) {
              ctx.fillStyle = clearColor;
              ctx.fillRect(0, 0, newWidth, newHeight);
            }
            ctx.drawImage(scratch, 0, 0, width, height, 0, 0, width, height);
            ctx.restore();
          }
          _doRedraw() {
            // Encapsulate common drawing and animation patterns in an easy
            // declatative structure
            let drawFn = this._drawFn;
            if (!(drawFn && this._staleImage && this._canvasFrameElement.parentElement)) return;
            let now = Date.now();
            if (now - this._drawTime > 200 /* ms */) // Stale stash -- heuristic!
              this._stashX = this._stashY = undefined;
            this._drawTime = now;
            let canvas2dRenderingContext = this._canvas2dRenderingContext, renderingContext = canvas2dRenderingContext;;
            let clearColor = this._clearColor;
            let canvasElement = this._canvasElement, canvasWidth = canvasElement.width, canvasHeight = canvasElement.height; 
            let backingCanvas = this._backingCanvas, backing2dRenderingContext = this._backing2dRenderingContext;
            let backingBufferWidth = this._backingBufferWidth, backingBufferHeight = this._backingBufferHeight;
            // If we're using a backing buffer make sure it (a) exists and (b) is big enough
            if (backingBufferWidth > 0 && backingBufferHeight > 0) {
              let neededWidth = backingBufferWidth > canvasWidth ? backingBufferWidth : canvasWidth;
              let neededHeight = backingBufferHeight > canvasHeight ? backingBufferHeight : canvasHeight;
              let oldBackingCanvas = backingCanvas, oldBacking2dRenderingContext = backing2dRenderingContext;
              if (!oldBackingCanvas || neededWidth !== oldBackingCanvas.width || neededHeight !== oldBackingCanvas.height) {
                backingCanvas = this._backingCanvas = createElement('canvas');
                backingCanvas.width = neededWidth;
                backingCanvas.height = neededHeight;
                this._backing2dRenderingContext = backing2dRenderingContext = backingCanvas.getContext('2d');
                contextToSchemeCanvasWidgetMap.set(backing2dRenderingContext, this);
                // Clear to the clearColor, if any
                if (clearColor) {
                  backing2dRenderingContext.save();
                  backing2dRenderingContext.fillStyle = clearColor;
                  backing2dRenderingContext.fillRect(0, 0, neededWidth, neededHeight);
                  backing2dRenderingContext.restore();
                }
                // Transfer old contents to the new buffer
                if (oldBackingCanvas) {
                  let w = oldBackingCanvas.width, h = oldBackingCanvas.height;
                  if (neededWidth < w) w = neededWidth;
                  if (neededHeight < h) h = neededHeight;
                  backing2dRenderingContext.drawImage(oldBackingCanvas, 0, 0, w, h, 0, 0, w, h);
                  contextToSchemeCanvasWidgetMap.delete(oldBacking2dRenderingContext);
                } else {
                  let w = canvasElement.width, h = canvasElement.height;
                  if (neededWidth < w) w = neededWidth;
                  if (neededHeight < h) h = neededHeight;
                  backing2dRenderingContext.drawImage(canvasElement, 0, 0, w, h, 0, 0, w, h);
                }
              }
              renderingContext = backing2dRenderingContext;
            } else {
              if (backing2dRenderingContext) {
                this._backingCanvas = this._backing2dRenderingContext = undefined;
                contextToSchemeCanvasWidgetMap.delete(backing2dRenderingContext);
              }
            }
            // The spec says there's supposed to be a reset method, but MDN
            // doesn't mention it and, emperically, it doesn't exist (yet?).
            // https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-reset
            //   canvas2dRenderingContext.reset();
            // So instead, pop a buncha renderingContexts, reset the
            // transform and, optionally clear the screen
            for (let i = 0; i < 20; ++i);
              renderingContext.restore();
            renderingContext.resetTransform();
            renderingContext.save();  // So we can easily restore context (just above)
            if (this._clearCanvasMode || this._forceClear) {
              this._forceClear = false;
              if (clearColor) {
                renderingContext.save();
                renderingContext.fillStyle = clearColor;
                renderingContext.fillRect(0, 0, canvasWidth, canvasHeight);
                renderingContext.restore();
              } else {
                renderingContext.clearRect(0, 0, canvasWidth, canvasHeight);
              }
            }
            renderingContext.beginPath();  // Make sure no path parts hanging around
            drawFn(renderingContext, this._tickCount++);
            if (backingCanvas)
              canvas2dRenderingContext.drawImage(backingCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, canvasWidth, canvasHeight);
            this._staleImage = false;
          }
          redraw() {
            this._staleImage = true;
            requestAnimationFrame(_ => this._doRedraw());
          }
          startAnimation() {
            // Take special care to not get multiple animation loops going.
            if (this._animating) return;
            if (!(this._drawFn && this._animate && this._canvasFrameElement.parentElement)) return;
            this._animating = true;
            window.requestAnimationFrame(_ => drawAnimation(this));
            function drawAnimation(that) {
              that._staleImage = true;
              that._doRedraw();
              if (that._drawFn && that._animate && that._canvasFrameElement.parentElement)
                return window.requestAnimationFrame(_ => drawAnimation(that));
              that._animating = false;
            }
          }
          _startUserMedia(value) {
            let alreadyUsingMedia = this._userMedia;
            let userMedia = this._userMedia = value;
            let canvasFrameElement = this._canvasFrameElement;
            let userMediaElement = this._userMediaElement;
            if (userMedia && !alreadyUsingMedia) {
              if (userMediaElement)
                canvasFrameElement.removeChild(userMediaElement);
              let deep = true;
              userMediaElement = this._userMediaElement = userMediaTemplateElement.cloneNode(deep);
              userMediaElement.removeAttribute('id');
              canvasFrameElement.appendChild(userMediaElement);
              let muteElement = this._muteElement = userMediaElement.querySelector(".mute-toggle");
              muteElement.addEventListener('input', _ => { this._setGain() });
              let volumeElement = this._volumeElement = userMediaElement.querySelector(".volume");
              volumeElement.addEventListener('input',  _ => { this._setGain()});
              this._userMediaStream = this._audioSource = this._gainNode = undefined;
              let audioContext = this._audioContext= new AudioContext();
              let that = this;
              startMedia(userMedia);
              async function startMedia(constraints) {
                try {
                  let userMediaStream = that._userMediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                  let audioSource = that._audioSource= audioContext.createMediaStreamSource(userMediaStream);
                  let gainNode = that._gainNode = audioContext.createGain();
                  that._setGain();
                  audioSource.connect(gainNode);
                } catch (error) {
                  console.log("GET-USER-MEDIA-ERROR", error);
                }
              }
            } else if (!userMedia && alreadyUsingMedia) {
              if (userMediaElement)
                canvasFrameElement.removeChild(userMediaElement);
              this._userMediaElement = undefined;
              this._userMediaStream = this._audioContext = this._audioAnalyser = undefined;
              this._frequencyDataArray = this._timeDomainDataArray = new Uint8Array(1);
            }
          }
        };

        exportAPI("create_canvas_widget", createCanvasWidget, { dontInline: true });
        defineBinding("create-canvas-widget", "create_canvas_widget", { group: "web-gfx" } );
        function createCanvasWidget(name = "canvas", width = 200, height = width) {
          let canvasFrameElement = createElement('div', 'canvas-frame');
          let canvasTitleBar = createElement('div', 'title-bar');
          let titleSpan = createElement('span', 'title', name);
          let canvasCloseButtonElement = createElement('close-button');
          canvasTitleBar.appendChild(canvasCloseButtonElement);
          canvasTitleBar.appendChild(titleSpan);
          let canvasElement = createElement('canvas', 'drawing-canvas');
          canvasFrameElement.appendChild(canvasTitleBar);
          canvasFrameElement.appendChild(canvasElement);
          let canvas2dRenderingContext = canvasElement.getContext('2d');
          let schemeCanvasWidget = new SchemeCanvasWidget(canvasFrameElement, canvasElement);
          contextToSchemeCanvasWidgetMap.set(canvas2dRenderingContext, schemeCanvasWidget);
          canvasCloseButtonElement.addEventListener('click', _ => schemeCanvasWidget.hide());
          canvasFrameElement.addEventListener('mousedown', mouseDown);
          canvasFrameElement.addEventListener('touchstart', mouseDown);
          canvasFrameElement.addEventListener('mousemove', updateCursor);
          let resizeBorder = 12, mouseIsDown = false;
          function getDragInfo(event) {
            let { pageX, pageY } = event;
            let { top, right, left, bottom } = canvasFrameElement.getBoundingClientRect();
            let i = 0;
            if (pageX < left + resizeBorder) i = 0;
            else if (pageX > right - resizeBorder) i = 2;
            else i = 1;
            if (pageY < top + resizeBorder) i += 0;
            else if (pageY > bottom - resizeBorder) i += 6
            else i += 3;
            let [fx, fw, fy, fh, cursor] = [
              [1, -1, 1, -1, "nwse-resize"], [0, 0, 1, -1, "ns-resize"], [0, 1, 1, -1, "nesw-resize"],
              [1, -1, 0,  0, "ew-resize"  ], [1, 0, 1,  0, "grabbing" ], [0, 1, 0,  0, "ew-resize"  ],
              [1, -1, 0,  1, "nesw-resize"], [0, 0, 0,  1, "ns-resize"], [0, 1, 0,  1, "nwse-resize"],
            ][i];
            return { pageX, pageY, fx, fw, fy, fh, cursor, top, right, left, bottom };
          }
          function updateCursor(event) {
            let { cursor } = getDragInfo(event);
            canvasFrameElement.style.cursor = cursor;
          }
          function mouseDown(event) {
            event.stopPropagation();
            let { pageX, pageY, fx, fw, fy, fh, top, right, left, bottom } = getDragInfo(event);
            let canvasWidth = canvasElement.width, canvasHeight = canvasElement.height;
            let initialX = pageX, initialY = pageY;
            function mouseMove(event) {
              event.stopPropagation();
              ({pageX, pageY} = event);
              let deltaX = pageX - initialX, deltaY = pageY - initialY;
              setTimeout(_ => { // defer so as not to interfere with click events; e.g. the close button
                if (canvasFrameElement.parentNode)
                  canvasFrameElement.parentNode.appendChild(canvasFrameElement);
              });
              if (fx !== 0) schemeCanvasWidget.x = left + fx * deltaX;
              if (fy !== 0) schemeCanvasWidget.y = top + fy * deltaY;
              if (fw !== 0) schemeCanvasWidget.width = canvasWidth + fw * deltaX;
              if (fh !== 0) schemeCanvasWidget.height = canvasHeight + fh * deltaY;
            }
            function mouseUp(event) {
              event.stopPropagation();
              bodyElement.removeEventListener('mousemove', mouseMove);
              bodyElement.removeEventListener('touchmove', mouseMove);
              bodyElement.removeEventListener('mouseup', mouseUp);
              bodyElement.removeEventListener('mouseleave', mouseUp);
              bodyElement.removeEventListener('touchend', mouseUp);
              bodyElement.removeEventListener('touchcancel', mouseUp);
              setTimeout(_ => { // defer so as not to interfere with click events; e.g. the close button
                if (canvasFrameElement.parentNode)
                  canvasFrameElement.parentNode.appendChild(canvasFrameElement);
              });
            }
            bodyElement.addEventListener('mousemove', mouseMove);
            bodyElement.addEventListener('touchmove', mouseMove);
            bodyElement.addEventListener('mouseup', mouseUp);
            bodyElement.addEventListener('mouseleave', mouseUp);
            bodyElement.addEventListener('touchend', mouseUp);
            bodyElement.addEventListener('touchcancel', mouseUp);
          }
          newCanvasX += 25;
          newCanvasY += 25;
          schemeCanvasWidget.x = newCanvasX;
          schemeCanvasWidget.y = newCanvasY;
          schemeCanvasWidget.width = width;
          schemeCanvasWidget.height = height;
          schemeCanvasWidget.show();   // Not sure if this should happen by default, but for now...
          return schemeCanvasWidget;
        }

        exportAPI("canvas_gfx_context", canvas_gfx_context, { dontInline: true });
        defineBinding("canvas-gfx-context", "canvas_gfx_context", { group: "web-gfx" });
        function canvas_gfx_context(schemeCanvasWidget) {
          return schemeCanvasWidget.canvas2dRenderingContext;
        }

        function WidgetFunctionHook(fName) {
          return function widgetHookFn(args, ssaScope, tools) {
            let compileEval = tools.compileEval, emit = tools.emit, newTemp = tools.newTemp, bind = tools.bind, use = tools.use;
            let ssaCRC = ssaScope[gfxContextAtom];
            if (!ssaCRC)
              ssaCRC = compileEval(gfxContextAtom, ssaScope, tools);
            let ssaContextToSchemeWidget = use(bind(contextToSchemeCanvasWidget, "contextToSchemeWidget"));
            let ssaWidget = newTemp("canvas_widget");
            emit(`let ${ssaWidget} = ${ssaContextToSchemeWidget}(${ssaCRC});`);
            let ssaArgStr = '', sep = '';
            for (let arg of args)
              ssaArgStr += `${sep}${arg}`, sep = ', ';
            emit(`${ssaWidget}.${fName}(${ssaArgStr});`);
            return ssaCRC;
          }
        }

        function WidgetPropertyHook(propName) {
          return function widgetHookProp(args, ssaScope, tools) {
            let compileEval = tools.compileEval, emit = tools.emit, newTemp = tools.newTemp, bind = tools.bind, use = tools.use;
            let ssaCRC = ssaScope[gfxContextAtom];
              if (!ssaCRC)
                ssaCRC = compileEval(gfxContextAtom, ssaScope, tools);
              let ssaContextToSchemeWidget = use(bind(contextToSchemeCanvasWidget, "contextToSchemeWidget"));
              let ssaWidget = newTemp("canvas_widget");
              emit(`let ${ssaWidget} = ${ssaContextToSchemeWidget}(${ssaCRC});`);
              let ssaRes = newTemp(propName + '_value');
              emit(`let ${ssaRes} = ${ssaWidget}.${propName};`);
              if (args.length > 0) {
                let ssaVal = args[0];
                emit(`if (${ssaVal} !== undefined)`);
                emit(`  ${ssaWidget}.${propName} = ${ssaVal};`);
              }
              return ssaRes;
          }
        }

        // Override canvas-width and canvas-height defined in SchemeJSWeb.mjs to use the width and height
        // of the non-backing canvas, regardless of which canvas the client is drawing on
        exportAPI("canvas_width", canvas_width, { compileHook: WidgetPropertyHook('width') });
        function canvas_width() {
          let ctx = this[gfxContextAtom];
          let schemeCanvasWidget = contextToSchemeCanvasWidget(ctx);
          return schemeCanvasWidget._canvasElement.width;
        };
        defineBinding("canvas-width", "canvas_width", { group: "web-gfx",
          sample: `(canvas-width) -or- (canvas-width new-width)`,
          blurb:  `Returns the current canvas width and optionally sets it to a new value.` });

        exportAPI("canvas_height", canvas_height, { compileHook: WidgetPropertyHook('height') });
        function canvas_height() {
          let ctx = this[gfxContextAtom];
          let schemeCanvasWidget = contextToSchemeCanvasWidget(ctx);
          return schemeCanvasWidget._canvasElement.height;
        };
        defineBinding("canvas-height", "canvas_height", { group: "web-gfx",
          sample: `(canvas-height) -or- (canvas-height new-width)`,
          blurb:  `Returns the current canvas height and optionally sets it to a new value.` });

        exportAPI("stash_point", stash_point, { compileHook: stash_point_hook });
        function stash_point(x, y) {
          let ctx = this[gfxContextAtom];
          let schemeCanvasWidget = contextToSchemeCanvasWidget(ctx);
          schemeCanvasWidget._stashX = x;
          schemeCanvasWidget._stashY = y;
          return ctx;
        };
        function stash_point_hook(args, ssaScope, tools) {
          let compileEval = tools.compileEval, emit = tools.emit, newTemp = tools.newTemp, bind = tools.bind, use = tools.use;
          let ssaCRC = ssaScope[gfxContextAtom];
          if (!ssaCRC)
            ssaCRC = compileEval(gfxContextAtom, ssaScope, tools);
          let ssaContextToSchemeWidget = use(bind(contextToSchemeCanvasWidget, "contextToSchemeWidget"));
          let ssaWidget = newTemp("canvas_widget");
          emit(`let ${ssaWidget} = ${ssaContextToSchemeWidget}(${ssaCRC});`);
          emit(`${ssaWidget}._stashX = ${args[0] ?? undefined};`);
          emit(`${ssaWidget}._stashY = ${args[1] ?? undefined};`);
          return ssaCRC;
        }
        defineBinding("stash-point", "stash_point", { group: "web-gfx", sample: `(stash-point x y)`,
          blurb: `Stashes the point with the containing canvas widget so that subsequent ` +
                 `animation iterations can call (line-to-stashed) or (move-to-stashed).` });

        exportAPI("move_to_stashed", move_to_stashed, { compileHook: MoveLineStashHook('moveTo') });
        function move_to_stashed() {
          let ctx = this[gfxContextAtom];
          let schemeCanvasWidget = contextToSchemeCanvasWidget(ctx);
          if (schemeCanvasWidget && schemeCanvasWidget._stashX !== undefined && schemeCanvasWidget._stashY !== undefined)
          ctx.moveTo(schemeCanvasWidget._stashX, schemeCanvasWidget._stashY);
          return ctx;
        };
        function MoveLineStashHook(op) {
          return function move_or_line_to_stashed(args, ssaScope, tools) {
            let compileEval = tools.compileEval, emit = tools.emit, newTemp = tools.newTemp, bind = tools.bind, use = tools.use;
            let ssaCRC = ssaScope[gfxContextAtom];
            if (!ssaCRC)
              ssaCRC = compileEval(gfxContextAtom, ssaScope, tools);
            let ssaContextToSchemeWidget = use(bind(contextToSchemeCanvasWidget, "contextToSchemeWidget"));
            let ssaWidget = newTemp("canvas_widget"), ssaX = newTemp('stashedX'),ssaY = newTemp('stashedY');
            emit(`let ${ssaWidget} = ${ssaContextToSchemeWidget}(${ssaCRC});`);
            emit(`let ${ssaX} = ${ssaWidget}._stashX, ${ssaY} = ${ssaWidget}._stashY;`);
            emit(`if (${ssaX} !== undefined && ${ssaY} !== undefined) ${ssaCRC}.${op}(${ssaX}, ${ssaY});`);
            return ssaCRC;
          }
        }
        defineBinding("move-to-stashed", "move_to_stashed", { group: "web-gfx", sample: `(move-to-stashed)`,
            blurb: `Moves to a point previously stashed using (stash-point x y)` });

        exportAPI("line_to_stashed", line_to_stashed, { compileHook: MoveLineStashHook('lineTo') });
        function line_to_stashed() {
          let ctx = this[gfxContextAtom];
          let schemeCanvasWidget = contextToSchemeCanvasWidget(ctx);
          if (schemeCanvasWidget && schemeCanvasWidget._stashX !== undefined && schemeCanvasWidget._stashY !== undefined)
          ctx.lineTo(schemeCanvasWidget._stashX, schemeCanvasWidget._stashY);
          return ctx;
        };
        defineBinding("line-to-stashed", "line_to_stashed", { group: "web-gfx", sample: `(line-to-stashed)`,
            blurb: `Draws a lint to a point previously stashed using (stash-point x y)` });

        exportAPI("clear_canvas", clear_canvas, { compileHook: WidgetFunctionHook('clear_canvas') });
        defineBinding("clear-canvas", "clear_canvas", { group: "web-gfx", sample: `(clear-canvas)`,
            blurb: `Clears the canvas)` });

        function clear_canvas() {
          let ctx = this[gfxContextAtom];
          let schemeCanvasWidget = contextToSchemeCanvasWidget(ctx);
          schemeCanvasWidget._clear_canvas();
          return ctx;
        };

        exportAPI("show_canvas", show_canvas, { compileHook: WidgetFunctionHook('show_canvas') });
        function show_canvas(x = optional, y = optional, width = optional, height = optional) {
          let ctx = this[gfxContextAtom], schemeCanvasWidget = contextToSchemeCanvasWidget(ctx);
          schemeCanvasWidget.show(x, y, width, height);
          return ctx;
        };
        defineBinding("show-canvas", "show_canvas", { group: "web-gfx" });

        exportAPI("hide_canvas", hide_canvas, { compileHook: WidgetFunctionHook('hide_canvas') });
        defineBinding("hide-canvas", "hide_canvas", { group: "web-gfx" });
        function hide_canvas() {
          let ctx = this[gfxContextAtom], schemeCanvasWidget = contextToSchemeCanvasWidget(ctx);
          schemeCanvasWidget.hide();
          return ctx;
        };
      }

      function handleInput(enterKey) {
        let parseContext = [], assignSyntax = true;
        let inputText = getElementText(inputElement);
        // console.log("TEXT", inputText);
        let pos = getSelectionPosition(inputElement);
        for (let span of inputElement.querySelectorAll('span'))
          span.replaceWith(span.textContent);
        inputElement.normalize();
        try {
          function* characterGenerator() {
            let part1 = inputText.substr(0, pos), part2 = inputText.substr(pos);

            // Feed parser part up to the cursor
            for (let ch of part1)
              yield ch;

            // Colorize opening grouping symbols
            let alpha = 1, fade = .6;
            for (let i = parseContext.length; i > 0; --i) {
              let tok = parseContext[i-1], pos = tok.position, width = 1;
              if (typeof tok.value === 'string') width = tok.value.length;
              colorizeCharsAt(inputElement, pos, width, 'match-tokens',
                `background-color: rgba(255, 200, 0, ${alpha}); color: blue`);
              alpha *= fade;
            }

            let depth = parseContext.length;
            alpha = 1;
            // Feed the rest
            for (let ch of part2) {
              yield ch;
              if (parseContext.length < depth) {
                let tok = parseContext.currentToken, pos = tok.position, width = 1;
                if (typeof tok.value === 'string') width = tok.value.length;
                if (tok.endPosition)
                  pos = tok.endPosition;
                if (tok.endWidth)
                  width = tok.endWidth;
                colorizeCharsAt(inputElement, pos, width, 'match-tokens',
                  `background-color: rgba(255, 200, 0, ${alpha}); color: blue;`);
                alpha *= fade;
                depth = parseContext.length;
              }
            }
            insertTextAndSetCursorAfter(inputElement, pos, "");
          }

          // Parse
          let expr = globalScope.parseSExpr(characterGenerator(), { parseContext, assignSyntax });

          if (!(enterKey && pos === inputText.length))
            return; // TODO: auto-indent the line-break

          let loadPath = null, loadLine = null;
          inputElement.textContent = '';
          ++varNo;
          showInput(inputText, loadPath, loadLine, expr, varNo);

          // Eval
          let value = globalScope._eval(expr, globalScope);

          // Show results and save in variables for later reuse
          showResult(value, varNo);
        } catch (error) {
          if (error instanceof SchemeParseError) {
            if (error instanceof SchemeSyntaxError) {
              let position = error.position;
              colorizeCharsAt(inputElement, position, inputText.length - position, 'error-tokens');
            }
            let indent = "";
            if (enterKey && parseContext.currentToken?.type !== 'string' && parseContext.length > 0)
              indent =  NBSP.repeat(parseContext[parseContext.length-1].lineChar + 2);
            insertTextAndSetCursorAfter(inputElement, pos, indent);
          } else {
            showError(error);
          }
        }
      }

      function showInput(inputText, path, line, expr, varNo) {
        // Show results and save in variables for later reuse
        inputText = trimEndNewlines(inputText);
        let div = createElement('div', 'input-box');
        if (varNo != null && expr !== undefined) {
          let name = `?${varNo}`;
          globalScope[Atom(name)] = expr;
          div.appendChild(createElement('span', 'tag', name));
        }
        let innerDiv = createElement('div', 'input-scroller');
        if (path != null)
          innerDiv.appendChild(createElement('div', 'load-path', `${path}, line ${line}:`));
        for (let pgf of convertToHTMLContent(inputText, 'text'))
          innerDiv.appendChild(pgf);
        div.appendChild(innerDiv);
        outputElement.appendChild(div);
        div.scrollIntoView();
      }

      function trimEndNewlines(str) {
        while (NL[str[str.length-1]])
          str = str.substr(0, str.length-1);
        return str;
      }

      function showResult(value, varNo) {
        if (printBoxElement)
          printBoxElement = undefined;
        let div = createElement('div', 'result-box');
        if (varNo != null) {
          let name = `=${varNo}`;
          globalScope[Atom(name)] = value;
          div.appendChild(createElement('span', 'tag', name));
        }
        let innerDiv = createElement('div', 'result-scroller');
        let evaluatedString = globalScope.string(value);
        for (let pgf of convertToHTMLContent(evaluatedString, 'text'))
          innerDiv.appendChild(pgf);
        div.appendChild(innerDiv);
        outputElement.appendChild(div);
        div.scrollIntoView();
      }

      function linePrinter(line) {
        if (!printBoxElement)
          printBoxElement = createElement('div', 'print-box');
        let innerDiv = createElement('div', 'print-scroller');
        for (let pgf of convertToHTMLContent(line+'\n', 'text'))
          innerDiv.appendChild(pgf);
        printBoxElement.appendChild(innerDiv);
        outputElement.appendChild(printBoxElement);
        printBoxElement.scrollIntoView();
      }

      function showError(error) {
        console.error("Error", error);
        let errorElement = createElement('div', 'error-box', String(error));
        outputElement.appendChild(errorElement)
        errorElement.scrollIntoView();
      }

      function convertToHTMLContent(text, cls) {
        let divs = [], line = '';
        for (let ch of text) {
          if (NL[ch]) {
            addDiv(line);
            line = '';
          }
          if (WS[ch])
            ch = NBSP;
          line += ch;
        }
        if (line !== '')
          addDiv(line);
        return divs;
        function addDiv(line) {
          let element = createElement('div', cls, line.replaceAll(' ', NBSP));
          if (line === '')
            element.appendChild(createElement('br'));
          divs.push(element);
        }
        return res;
      }

      function getSelectionPosition(editableElement) {
        let selection = window.getSelection();
        // console.log("SEL", selection.anchorNode, selection.anchorOffset, selection);
        if (!selection) return undefined;
        let anchorNode = selection.anchorNode;
        let selectionPosition = selection.anchorOffset;
        if (!editableElement.contains(anchorNode)) return undefined;
        traverseEditableElement(editableElement, onNode);
        // console.log("POS", selectionPosition);
        return selectionPosition;
        function onNode(node, pos, isNewline) {
          // console.log ("GSP", pos, node.tagName, node.data);
          if (node === anchorNode) {
            selectionPosition += pos;
            return true;
          }
        }
      }

      function getElementText(element) {
        let text = '';
        traverseEditableElement(element, onNode);
        // Parser recognizes NBSP as whitespace but know that they're there!
        // text = text.replaceAll(NBSP, ' ');
        // console.log("GET", text);
        return text;
        function onNode(node, pos, isNewline) {
          if (isNewline)
            text += '\n';
          if (node instanceof Text)
            text += node.data;
        }
      }

      function insertTextAndSetCursorAfter(element, insertPosition, text = '') {
        // console.log("ISC", insertPosition, text);
        let selection = window.getSelection();
        if (!selection) return false;
        return traverseEditableElement(element, onNode);
        function onNode(node, pos, isNewline) {
          let localPos = insertPosition - pos;
          // console.log ("ITA", localPos, node.tagName, node.data);
          if (localPos < 0) return;
          if (node instanceof Text) {
            // console.log ("ITA TEXT");
            let content = node.data;
            if (localPos <= node.data.length) {
              if (text !== '') {
                content = content.substr(0, localPos) + text + content.substr(localPos);
                node.textContent = data;
              }
              selection.collapse(node, localPos);
              return true;
            }
          } else if (node instanceof Element) {
            if (localPos < 0) return false;
            if (localPos === 0) {
              // console.log ("ITA ELEMENT");
              let textNode = document.createTextNode(text);
              if (node.tagName === 'BR' && node.parentElement.tagName === 'DIV') {
                node.replaceWith(textNode);
              } else {
                node.prepend(textNode);
                selection.collapse(textNode, text.length);
              }
              return true;
            }
          }
        }
      }

      function colorizeCharsAt(element, colorizePosition, nchar, cls, style) {
        // console.log("COLORIZE!", colorizePosition, nchar, cls, style);
        return traverseEditableElement(element, onNode);
        function onNode(node, pos, isNewline) {
          let localPos = colorizePosition - pos;
          // console.log("COLORIZE", localPos, node.tagName, node.data);
          if (localPos < 0) return;
          if (node instanceof Text) {
            let text = node.data;
            if (localPos < text.length) {
              let before, replace, after, n = nchar;
              if (n > text.length - localPos)
                n = text.length - localPos;
              if (localPos === 0) {
                replace = node;
                if (n < text.length)
                  after = node.splitText(n);
              } else {
                before = node;
                replace = node.splitText(localPos);
                if (n < replace.textContent.length)
                  after = replace.splitText(n);
              }
              let highlightElement = createElement('span', cls, replace.textContent);
              if (style)
                highlightElement.setAttribute('style', style);
              node.parentElement.replaceChild(highlightElement, replace);
              nchar -= n;
              colorizePosition += n;
              if (nchar <= 0) return true;
            }
          }
        }
      }

      function traverseEditableElement(editableElement, onNode) {
        let pos = 0;
        return traverse(editableElement);
        function traverse(node) {
          let isReturn = false;
          if (node.parentElement === editableElement && node.previousSibling && node.tagName === 'DIV') {
              pos += 1;
              isReturn = true;
          }
          if (node !== editableElement) {
            let res = onNode(node, pos, isReturn);
            if (res !== undefined) return res;
          }
          if (node instanceof Element) {
            for (let child of node.childNodes) {
              let res = traverse(child);
              if (res !== undefined) return res;
            }
          } else if (node instanceof Text) {
            pos += node.data.length;
          }
        }
      }

      function runUnitTests() {
        runTests();
        async function runTests() {
          let traceCompilerCode = true;
          let UnitTest = await(import("./UnitTest.mjs"));
          UnitTest.run({ throwOnError: false, traceCompilerCode });
        }
      }

      if ('serviceWorker' in navigator && window.location.protocol === 'https:')
        navigator.serviceWorker.register('service-worker.js');

      try { loadState(); } catch (e) {} // inconvenient to crash while loading
   </script>
  </body>
</html>