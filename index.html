<!DOCTYPE html>
<!--
  SchemeJS: Scheme in JavaScript

  Copyright 2021 Stan Switzer -- (sjswitzer [at] gmail [dot] com)
    This work is licensed under a Creative Commons Attribution-ShareAlike
    4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/
-->
<html>
  <head>
    <title>SchemeJS: Scheme in JavaScript</title>
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="viewport" content="width=device-width">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <meta name="format-detection" content="telephone=no">
    <link rel="apple-touch-icon" href="icon128.png">
    <link rel="manifest" href="manifest.webmanifest">
    <base target="_blank"> <!-- all links open in a new tab/page -->
    <style type="text/css">
      html {
        -webkit-text-size-adjust: none
      }

      * { /* input elements lay out bizarrely without this since their borders aren't part of their size */
        box-sizing: border-box;
      }

      body {
        padding: .2em .5em;
        margin: 0em 0em;
        background-color: #f8f8f8;
        text-size-adjust: none;   /* keep mobile browsers from getting sneaky with sizing */
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
      html, table  {
        font: 100% caption, sans-serif;
      }
      @media all and (orientation:landscape) {
        /* iPhone crowds the screen in portrait but has lots of padding in landscape
           because they don't give you the slot or curved corner areas. So kill the padding there. */
        body[data-device="mobile"] {
          padding: 0px 0px;
        }
      }

      /*
       * A trick to let the app switch to mobile mode on the fly.
       * Javascript flips the --device property into the
       * body element's data-device attribute, but the app
       * can change it later.
       */
      @media (hover: none) {
        body {--device: mobile;}
      }
      body:not([data-device="mobile"]) .mobile-only {
        display: none;
      }
      body[data-device="mobile"] .desktop-only {
        display: none;
      }
      body:not([data-protocol="file:"]) .local-only {
        display: none;
      }
      body[data-protocol="file:"] .remote-only {
        display: none;
      }

      /*
       * Initially-hidden help content.
       * Help contains a custom <close-button> and
       * a <div> for help content which is made scrollable.
       */
      div.help {
        padding: 0;
        background-color: #e8e8e8;
        position: absolute;
        display: none;
        top: 10%;
        left: 45%;
        right: .5em;
        bottom: .5em;
        border: .15em solid black;
        border-radius: .5em;
      }
      div.help > * {
        margin: 0 1em;
      }
      div.help > .top {
        margin: 0 0;
        padding: 0 1em .5em 1em;
        border-bottom: .05em solid black;
      }
      div.help > close-button {
        z-index: 1;
        color: #0005;  /* rather transparent black */
        font-size: 150%;
        --close-button-x-thick: 35%;
        position: absolute;
        top: .3em;
        right: .3em;
        transition: .25s;
      }
      div.help > close-button:hover {
        font-size: 160%;
        color: black;
      }
      div.help > .help-content {
        overflow-y: auto;
        height: 100%;
      }

      .help dl,
      .help dl dt,
      .help dl dd {
        display: block;
        /*
         * "overflow:auto" creates a "block formatting context" while "dislpay:block" does not!
         * I *think* "contain: paint" is more sensible, though, but only seems to work in Chrome.
         * Look up "CSS block formatting context." It's wild!
         */
        overflow: auto;
        contain: paint;
      }
      .help dl {
        margin: .25em 0 .25em 0;
      }
      .help dl dt {
        float: left;
        clear: right;
        margin-inline-end: 1ch;
      }
      .help dl dd {
        float: right;
        margin-inline-start: unset;
        --definition-margin: 11ch;
        --definition-percent: 80%;
        width: max(var(--definition-percent), calc(100% - var(--definition-margin)));
      }
      .help dl dd,
      .help dl dt {
        padding-top: .5em;
      }
      .help dl .heading {
        font-weight: bold;
        font-style: normal !important;
      }
      .help dd p {
        margin: .5em 0 .5em 0;
      }

      .help dl p.impl,
      .help dl p.value {
        color: #555;
      }

      .help .impl:before { content: "Impl: " }
      .help .value:before { content: "Value: " }
      .help .js-names:before { content: "JavaScript: " }
      .help .impl, .help .value, .help .js-names { display: none }
      div[data-show-impl="true"] .impl, .help[data-show-impl] .value { display: block; }
      div[data-show-javascript="true"] .js-names { display: block; }

      #helpgroup-imported dl {
        display: block;
      }
      #helpgroup-imported dt {
        display: span;
        font-style: italic;
      }
      #helpgroup-imported dd {
        display: none;
      }

      .help .example {
        font-style: italic;
      }

      .help .definitions dd {
        font-style: italic;
      }
      .help .definitions dd p {
        font-style: normal;
      }

      #help-details dl dd {
        --definition-margin: 5ch;
      }

      .help ul {
        padding-left: 1.25em;
      }
      .help ul > li {
        margin: .5em;
      }

      code {
        font-style: italic;
        font-family: caption, sans-serif;
      }

      /*
       * Makes a <span> into a "button"
       */
      span.button {
        display: inline-block;
        cursor: pointer;
        padding: .2em .6em;
        background: #44f;
        border-radius: .5em;
        color: white;
      }
      span.button:hover {
        background: #0000dd;
      }
      span.button:active {
        background: #0000cc;
      }
      span.padded-button {
        padding: .2em 1.5ch;
      }

      /* greasy way to make a text-delete button in the input box */
      .clear-text-button {
        position: relative;
        width: 0;
      }
      .clear-text-button > close-button {
        position: absolute;
        bottom: .15em;
        left: -2em;
        color: white;
        --close-button-box-color: #8e8d92;
        --close-button-box-radius: 50%;
        --close-button-x-thick: 25%;
        --close-button-x-size: 55%;
        padding: .05em .4em;
      }

      /* Looks like a link but is actually a "button" */
      span.linklike {
        color: #00d;
        cursor: pointer;
        text-decoration: underline;
      }

      #container {
        display: flex;
        flex-flow: column nowrap;
        overflow: hidden;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: 0;
        padding: .25em .25em .25em .25em;
      }

      #header {
        display: flex;
        flex: 0 10 auto;
        flex-flow: row nowrap;
        width: 100%;
        font-size: 160%;
      }

      #header #title {
        flex: 1 0 auto;
        align-self: flex-end;
      }
      #lambda {
        font-size: 150%;
        margin-right: .15em;
      }

      #header #about {
        flex: 0 0 auto;
      }

      #output, #input {
        font-family: Lucida Console, Monaco, Consolas, Courier New, monospace;
        font-size: 90%;
      }

      #output {
        /* https://geon.github.io/programming/2016/02/24/flexbox-full-page-web-app-layout */
        flex: 1 1 25em;
        overflow: scroll;
        justify-content: flex-end;
        margin-top: 0.1em;
        padding: .15em .15em .15em .15em;
        width: 100%;
        background-color: #ccc;
        border: .1em solid;
        border-radius: .5em;
      }
      #output .input-box, #output .result-box, #output .print-box, #output .error-box {
        position: relative;  /* so that the "tag"" can be positioned absolutely */
        justify-self: end;
        margin-top: 0.25em;
        border: .1em solid;
        border-radius: .5em;
      }
      #output .tag {
        position: absolute;  /* parent div must be position: relative */
        opacity: .5;
        top: 0;
        right: 0;
        margin: 0.3em 0.3em 0 0;
        padding: 0.1em 0.25em 0.1em 0.25em;
        font-size: 90%;
        border: .1em solid;
        border-radius: .5em;
        background-color: #ddd;
      }
      #output .input-scroller, #output .result-scroller, #output .print-scroller {
        overflow: scroll;
        min-height: 2em;
      }
      #output .result-scroller {  max-height: 20em; }
      #output .print-scroller {  max-height: 100em; }
      #output .result-scroller { padding: .5em .5em .5em .5em }
      #output .error-box { padding: .5em .5em .5em .5em }
      #output .input-scroller { padding: 0 0 .5em 0 }
      #output .input-scroller .text { margin: 0 .5em 0 .5em }
      #output .input-scroller .text:first-child { margin-top: .5em }
      #output { background-color: #eeeeee }
      #output .input-box { background-color: #ffffff }
      #output .result-box { margin-left: 1em; background-color: #f8f8f8 }
      #output .error-box { margin-left: 1em; background-color: #ffbbbb }
      #output .print-box { margin-left: 1em; background-color: #ffffcc }
      #output .load-path {
        margin-bottom: .5em;
        padding: .25em;
        background-color: #d6d6fd;
       }

      #scratch { color:hsl(46, 100%, 50%) }

      /* The input box */
      #input {
        flex: 0 0 4em;
        margin-top: 0.25em;
        padding: .5em .5em .5em .5em;
        width: 100%;
        border: .1em solid;
        border-radius: .5em;
        background-color: #ffffff;
      }
      #input .match-tokens {
        border-radius: .5em;
      }
      #input .error-tokens {
        background-color: rgb(252, 124, 124);
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="header">
        <div id="title"><span id="lambda">&lambda;</span> SchemeJS: Scheme in JavaScript</div>
        <div id="about">
          <span class="button" style="font-size: 80%;" onclick="showHelp('help-about')"> ? </span>
        </div>
      </div>
      <div id="output"></div>
      <div id="input" spellcheck="false"></div>
    </div>
    <div class="help" id="help-about">
      <close-button onclick="showHelp(null)"></close-button>
      <div class="help-content">
        <h2> SchemeJS: Scheme in JavaScript </h2>
        <p> JavaScript has dynamic typing, functions, closures, and a JIT with
            a small army of crack programmers optimizing its performance.
            It’s an ideal runtime for Scheme.
            All it lacks is cons cells, an s-expression parser/printer,
            eval/apply, and a handful of Lisp primitives.
        <p> Oh, and a compiler that compiles Scheme down to perfectly normal
            JavaScript functions that JavaScript JITs can go to town on.
        <p> SchemeJS fills that gap.
        <p> It’s hard to keep JavaScript objects from sneaking into the
            SchemeJS world, so I decided to invite them in as first-class.
            SchemeJS is fully Scheme <i>and</i> fully JavaScript.
        <p> This implementation aims for broad compatibility with SIOD, but inevitably,
            and in the grand tradition of list implementations, introduces a new dialect.
            Which is a sin but not a crime.
        <p> Run a demo by typing <code>(load "demo.scm")</code>.
        <p> Learn about
            <span class="linklike" onclick="showHelp('help-builtin')"">built-in Scheme definitions</span> and
            <span class="linklike" onclick="showHelp('help-details')"">implementation details</span>.
      </div>
    </div>
    <div class="help" id="help-details">
      <close-button onclick="showHelp(null)"></close-button>
      <div class="help-content">
        <h2> Implementation Details </h2>
        <p>
        <h3> Key Features </h3>
        <h4> JavaScript Integration </h4>
        <p> SchemeJS and JavaScript have full and fluent access to each other's objects.
            SchemeJS can call invoke any JavaScript function and every SchemeJS
            function is a JavaScript function, <i>whether it is compiled or not</i>.
        <p> Syntax for JavaScript Object and Array literals.
        <p> Core SchemeJS primitives are implemented directly on fundamental
            JavaScript primitives such as function closures and prototype resolution.
            These are the things that JavaScript JITs optimize most thouroughly.
        <h4> Iteratable-Aware </h4>
        <p> SchemeJS lists are iterable in JavaScript and JavaScript iterables can be
            viewed as Scheme lists, either immediately or lazily.
        <p> SchemeJS built-in functions that operate on lists also operate on any JavaScript
            iterable such as Arrays.
        <h4> N-ary Comparisons </h4>
        <p> Comparison functions such as "<" can be applied to arbitrarily many arguments. In this case
            it means that each argument is less than the previous. Evaluation ends as soon as
            the comparison fails.
        <h4> Partial Function Application </h4
        <p> Functions, whether user-defined, compiled, or implemented in JavaScript, when
            invoked with fewer than their required number of parameters result
            in a <i>closure</i> that binds the given arguments.
            For instance, <code>(+ 5)</code> results in a function (closure) that
            adds 5 to its argument(s).
        <h4> Generalized Special Forms </h4> 
        <p]> Users can define "special forms" that take a specified number of evaluated parameters;
             the rest are unevaluated.
             In <code>(\# 2 (a1 a3 a3 a5) forms...)</code>, <i>a1</i> and <i>a2</i> are evaluated and the rest are not.
        <h4> Optional Parameters </h4>
        <p> A function defined as <code>(define (fn p1 (? p2 expr) (? p3 expr) ) form ...)</code>
            has optional parameters <code>p2</code> and <code>p3</code> with default values
            supplied by the expressions that follow them. The expressions are evaluated only
            if the parameter is absent.
        <h4> Rest Parameters </h4>
        <p> A function defined as <code>(define (fn p1 p2 . p3) form ...)</code> takes two
            normal parameters (<i>p1</i> and <i>p2</i>) and recieves a third parameter <i>p3</i>,
            that recieves a list of the remaining arguments.
        <p> Similarly, a lambda of the form <code>(&lambda; (p1 p2 . p3) form ...)</code> has a
            rest parameter <i>p3</i>.
        <h4> Curry Notation </h4>
        <p> If you like Curry notation, go ahead and use it!
            <code>(&lambda;x.(+ x 2))</code>. The evaluator, compiler and printer
            all understand it.
        <h4> Predicates as Conditionals </h4>
        <p> Predicates such as <code>number?</code> can be used to test a value's type
            and return a boolean, or as conditionals themselves.
        <h4> Lazy Lists and Map Functions </h4>
        <p> JavaScript iterators can be turned into lazy cons cells that don't fetch
            the next object until someone invokes <i>cdr</i>.
        <p> Lazy "map" is the same, but in addition the mapping function is not applied
            until someone invoke invokes <i>car</i> on the mapped list.
        <h4> Compiler </h4>
        <p> A compiler (a "transpiler," tchnicaly, but that sounds silly)
            that transforms Scheme into perfectly normal JavaScript that the
            JIT can go to town on.
        <h4> Easly Embedded </h4>
        <p> SchemeJS is a JavaScript module designed to be easily embedded into other applications.
            Scheme JS can run in any web page (in a sufficiently modern browser) and can do anything
            JavaScript can do with as few as a half dozen lines of code to import it.
        <p> It comes with a Node.js-based CLI/REPL and this web-based REPL but
            they're just simple embeddings of the SchemeJS runtime.
        <p> SchemeJS has <i>no dependencies</i> beyond a modern JavaScript runtime.
        <h4> Unicode </h4>
        <p> SchemeJS identifiers can use any Unicode "alphabetic" characters (including ideographs).
              People should be able to program in their own languages.
        <h3> Sundry </h3>
        <p> <span class="linklike" onclick="runUnitTests()">Run unit tests</span>; results
            display in the browser console. The compiler is curently configured to log compiled
            code to the console as well.
        <p> Copyright &copy; 2021, Stan Switzer &mdash; (sjswitzer [at] gmail [dot] com)
        <div style="width: 100%">
          This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            Creative Commons Attribution-ShareAlike 4.0 International License</a>.
          <br> Find source on
          <a href="https://github.com/sjswitzer/SchemeJS">GitHub</a>
          <p></p>
        </div>
      </div>
    </div>
    <div class="help" id="help-builtin">
      <close-button onclick="showHelp(null)"></close-button>
      <div class= "top"">
        <h2 style="margin-bottom:.25em"> Built-In Functions and Constants </h2>
        <input type="checkbox" name="impl"
          onchange="parentElement.parentElement.setAttribute('data-show-impl', String(event.currentTarget.checked))">
        <label for="javascript">Implementations</label>,
        <input type="checkbox" name="javascript"
          onchange="parentElement.parentElement.setAttribute('data-show-javascript', String(event.currentTarget.checked))">
        <label for="javascript">JavaScript API</label>
      </div>
      <div class="help-content">
        <dl class="definitions" id="helpgroup-builtin">
          <dt class="heading"> Symbol
            <dd class="heading"> Description
          <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h2> Functions and Constants Imported from JavaScript </h2>
        <dl class="definitions" id="helpgroup-imported">
           <!-- definitions inserted here when SchemeJS module is loaded -->
      </dl>
     </div>
    </div>
    <!-- These definitions get moved into the help section at startup -->
    <div style="display: none !important">
      <dd id="defn-*catch">
        (*catch "tag" form ...)
        <p> SIOD-style catch.
            Evaluates the forms until one of them calls
            <code>(*throw "tag" value)</code>.
            Returns "value" if the tags match; otherwise the exception propagates.
      </dd>
      <dd id="defn-*throw">
        (*throw "tag" value)
        <p> SIOD-style throw.
            Throws the value with the given tag.
            An enclosing <code>(*catch "tag" form ...)</code> will
            return "value" if the tags match; otherwise the exception propagates.
      </dd>
      <dd id="defn-catch">
        (catch catch-clause forms)
        <p> where <i>catch-clause</i> is:</p>
        (error type forms)
        <p> Java/JavaScript-style catch.
        <p> Evaluates the forms until one of them calls <code>(throw obj)</code>.
            If the <i>type</i> matches the thrown object,
            the <i>catch-clause</i> forms are evaluated with the thrown object bound
            to "<i>error</i>".
            If <i>type</i> is an object, the catch matches if the object is an instance
            of that object; it <i>type</i> is a string, the catch matches if it is the JavaScript
            "typeof" the thrown object.
      </dd>
      <dd id="defn-throw">
        (throw "tag" value)
        <p> Java/JavaScript-style-style throw.
            Throws the value with the given tag.
            An enclosing <code>(*catch "tag" form ...)</code> will
            return "value" if the tags match; otherwise the exception propagates.
        <p> For example:
        <p class="example">
            (catch (e "string" (+ "thrown: " e))<br>
            &nbsp;&nbsp; (+ 1 2)<br>
            &nbsp;&nbsp;  (+ 3 (throw "ha ha!"))<br>
            )
      </dd>
      <dd id="defn-*e*">
        Euler's constant and the base of natural logarithms
      </dd>
      <dd id="defn-*ln10*">
        Natural logarithm of 10
      <dd id="defn-*log10e*">
        Base-10 logarithm of Euler's constant
      </dd>
      <dd id="defn-*log2e*">
        Base-2 logarithm of Euler's constant
      </dd>
      <dd id="defn-*pi*">
        Ratio of the a circle's circumference to its diameter (&pi;)
      <dd id="defn-*sqrt1_2*">
        Square root of 1/2
      </dd>
      <dd id="defn-*sqrt2*">
        Square root of 2
      </dd>
      <dd id="defn-*ln2*">
        Natural logarithm of 2
      <dd id="defn-abs">
        (abs x)
        <p> Absolute value of <i>x</i>; <i>x</i> can be a number or a bigint.
      </dd>
      <dd id="defn-acos">
        (acos x)
        <p> Arccosine of x in radians.
      </dd>
      <dd id="defn-acosh">
        (acosh x)
        <p> Hyperbolic arccosine of x in radians.
      </dd>
      <dd id="defn-asin">
        (asin x)
        <p> Arcsine of x in radians.
      </dd>
      <dd id="defn-asinh">
        (asinh x)
        <p> Hyperbolic arcsine of x in radians.
      </dd>
      <dd id="defn-atan">
        (atan x)
        <p> Arctangent of x in radians.
      </dd>
      <dd id="defn-atanh">
        (atanh x)
        <p> Hyperbolic arctangent of x in radians.
      </dd>
      <dd id="defn-atan2">
        (atan2 y x)
        <p> Angle in radians from the positive x axis and the ray to the point (x, y).
            Does not suffer from divide-by-zero issues as <i>tan</i> would.
      </dd>
      <dd id="defn-sqrt">
        (sqrt x)
        <p> Square root of x.
      </dd>
      <dd id="defn-cbrt"><div>
        (cbrt x)
        <p> Cube root of x.
      </dd>
      <dd id="defn-clz32">
        (clz32 x)
        <p> Number of leading zeros in the binary representation of x
            considered as a 32-bit integer.
      </dd>
      <dd id="defn-cos">
        (cos x)
        <p> Cosine of x in radians.
      </dd>
      <dd id="defn-cosh">
        (cosh x)
        <p> Hyperbolic cosine of x in radians.
      </dd>
      <dd id="defn-expm1">
        (expm1 x)
        <p> The value <code>(- (exp x) 1)</code>, avoiding numerical anomalies.
      </dd>
      <dd id="defn-exp">
        (exp x)
        <p> Euler's number to the power x.
      </dd>
      <dd id="defn-floor">
        (floor x)
        <p> The largest integer less than or equal to x.
      </dd>
      <dd id="defn-ceil">
        (ceil x)
        <p>The smallest integer greater than or equal to x.
      </dd>
      <dd id="defn-fround">
        (fround x)
        <p> The closest single precision floating point representation of x.
      </dd>
      <dd id="defn-hypot">
        (hypot value ...)
        <p> The square root of the sum of the squares of the arguments.
      </dd>
      <dd id="defn-imul">
        (imul x y)
        <p> Result of the multiplication of x and y considered as 32-bit integers.
      </dd>
      <dd id="defn-log">
        (log x)
        <p> The natural logarithm of x.
      </dd>
      <dd id="defn-add">
        (+ value value ...)
        <p> Adds the values.
      </dd>
      <dd id="defn-sub">
        (- value ...)
        <p> Subtracts a series of values from the first value.
            If there is only one argument, negates the value.
      </dd>
      <dd id="defn-mul">
        (* value value ...)
        <p> Multiplies a series of values.
      </dd>
      <dd id="defn-div">
        (/ value ...)
        <p> Divides a series of values from the first value.
            If there is only one argument, returns the reciprocal.
      </dd>
      <dd id="defn-rem">
        (% value value)
        <p> Remainder of the first value divided by the second.
      </dd>
      <dd id="defn-pow">
        (** value value)
        <p> Exponentiates the first value by the second.
      </dd>
      <dd id="defn-and">
        (&& value value ...)
        <p> Evaluates its arguments until one of them is false.
            Results in the first "false" value; otherwise the last value.
            Evaluation ends when a false value is found.
            "False" values are
            <code>false</code>, <code>nil</code>, <code>undefined</code> and
            <code>null</code>; unlike JavaScript,
            zero, NaN and "" are <i>not</i> false.
      </dd>
      <dd id="defn-or">
        (|| value value ...)
        <p> Evaluates its arguments until one of them is true.
          Results in the first "true" value; otherwise the last value.
          Evaluation ends when a true value is found.
          "False" values are
          <code>false</code>, <code>nil</code>, <code>undefined</code> and
          <code>null</code>; unlike JavaScript,
          zero, NaN and "" are <i>not</i> considered false.
          Everything else is "true."
      </dd>
      <dd id="defn-bit-and">
        (& value value ...)
        <p> Bitwise "and" of the values considered as 32-bit integers.
      </dd>
      <dd id="defn-bit-or">
        (| value value ...)
        <p> Bitwise "or" of the values considered as 32-bit integers.
      </dd>
      <dd id="defn-bit-xor">
        (^ value value ...)
        <p> Bitwise exclusive "or" of the values considered as 32-bit integers.
      </dd>
      <dd id="defn-bit-not">
        (~ value)
        <p> Bitwise not of the value considered as a 32-bit integer.
      </dd>
      <dd id="defn-bit-shl">
        (&lt;&lt; value shift)
        <p> <i>Value</i> left-shifted "shift" bits, bith considered as 32-bit integers.
      </dd>
      <dd id="defn-bit-shr">
        (&gt;&gt; value shift)
        <p> <i>Value</i> arithmetcally right-shifted "shift" bits, bith considered as 32-bit integers.
            The sign bit fills from the left.
      </dd>
      <dd id="defn-bit-ushr">
        (&gt;&gt;&gt; value shift)
        <p> <i>Value</i> logically right-shifted "shift" bits, bith considered as 32-bit integers.
          Zero bits fill from the left.
      </dd>
      <dd id="defn-ash">
        (ash value shift)
        <p> Shifts left if <i>shift</i> is positive.
            Shifts arithmetcally right if <i>shift</i> is negative;
            sign bits fill from the left.
      </dd>
      <dd id="defn-append">
        (append list ...)
        <p> Appends the specified lists or iterable JavaScript objects, forming a new list.
      </dd>
      <dd id="defn-apply">
        (apply function args [scope])
        <p> Applies the function to the arguments in the given scope.
            "scope" is optional; the default is the current scope.
      </dd>
      <dd id="defn-begin">
        (begin form ...)
        <p> Evaluates the forms sequentially, returning the value of the last form.
      </dd>
      <dd id="defn-bigint?">
        (bigint? obj)
        <p> Returns <code>true</code> if <i>obj</i> is a JavaScript BigInt.
      </dd>
      <dd id="defn-boolean?">
        (boolean? obj)
        <p> Returns <code>true</code> if <i>obj</i> is a boolean.
      </dd>
      <dd id="defn-function?">
        (boolean? obj)
        <p> Returns <code>true</code> if <i>obj</i> is a JavaScript function.
      </dd>
      <dd id="defn-butlast">
        (butlast list)
        <p> A copy of <i>list</i> excepting the last element.
      </dd>
      <dd id="defn-caaar">
        (caaar list)
        <p> Shorthand for: <code>(car (car (car list)))</code>.
      </dd>
      <dd id="defn-caadr">
        (caadr list)
        <p> Shorthand for: <code>(car (car (cdr list)))</code>.
      </dd>
      <dd id="defn-caar">
        (caar list)
        <p> Shorthand for: <code>(car (car list))</code>.
      </dd>
      <dd id="defn-cadar">
        (cadar list)
        <p> Shorthand for: <code>(car (cdr (car list)))</code>.
      </dd>
      <dd id="defn-caddr">
        (caddr list)
        <p> Shorthand for: <code>(car (cdr (cdr list)))</code>.
      </dd>
      <dd id="defn-cadr">
        (cadr list)
        <p> Shorthand for: <code>(car (cdr list))</code>.
      </dd>
      <dd id="defn-cons">
        (cons first rest)
        <p> Returns a new list object with <i>first</i> as the "car" and <i>rest</i> as the "cdr."
      </dd>
      <dd id="defn-car">
        (car list)
        <p> First element of <i>list</i>.
      </dd>
      <dd id="defn-cdr">
        (cdr list)
        <p> Second and subsequent elements of <i>list</i>.
      </dd>
      <dd id="defn-cdaar">
        (cdaar list)
        <p> Shorthand for: <code>(cdr (car (car list)))</code>.
      </dd>
      <dd id="defn-cdadr">
        (cdadr list)
        <p> Shorthand for: <code>(cdr (car (cdr list)))</code>.
      </dd>
      <dd id="defn-cdar">
        (cdar list)
        <p> Shorthand for: <code>(cdr (car list))</code>.
      </dd>
      <dd id="defn-cddar">
        (cddar list)
        <p> Shorthand for: <code>(cdr (cdr (car list)))</code>.
      </dd>
      <dd id="defn-cdddr">
        (cdddr list)
        <p> Shorthand for: <code>(cdr (cdr (cdr list)))</code>.
      </dd>
      <dd id="defn-cddr">
        (cddr list)
        <p> Shorthand for: <code>(cdr (cdr list))</code>.
      </dd>
      <dd id="defn-closure?">
        (closure? obj)
        <p> True if <i>obj</i> is a Scheme closure.
      </dd>
      <dd id="defn-SchemeCompileError"
        <p> Thrown when the compiler finds an error.
      </dd>
      <dd id="defn-SchemeEvalError">
        <p> Thrown when the there is an error evaluating a Scheme form.
      </dd>
      <dd id="defn-cond">
        (cond cond-clause ...)
        <p> where <i>cond-clause</i> is:</p>
        (predicate form ...)
        <p> Evaluates each predicate sequentially until one is true then
            evaluates the forms in that clause, returning the value
            of the last form.
        <p class="example">
          (cond <br>
          &nbsp;&nbsp; ((< 6 4) "a") <br>
          &nbsp;&nbsp; ((< 4 4) "b") <br>
          &nbsp;&nbsp; ((< 3 4) "c") <br>
          &nbsp;&nbsp; ((< 2 4) "d"))
      </dd>
      <dd id="defn-copy-list">
        (copy-list list)
        <p> Returns a new list that is an element-wise shallow copy of <i>list</i>,
            which can be a Scheme list or JavaScript iterable.
      </dd>
      <dd id="defn-apropos">
        (apropos ["substring"])
        <p> A list of globally-defined functions and values.
            If an optional "substring" parameter is given, it returns only definitions
            whose name contains that substring.
      </dd>
      <dd id="defn-aref">
        (@ index array)
        <p> Indexes into the JavaScript array by the given index. </p>
        (@ "prop" obj)
        <p> The value of the property "prop" in the given object.
      </dd>
      <dd id="defn-aref?">
        (@? index array)
        <p> The value of the property "prop" in the given object or undefined if the array is
            undefined or null.</p>
        (@ "prop" obj)
        <p> The value of the property "prop" in the given object or undefined if the array is
            undefined or null.
      </dd>
      <dd id="defn-array?">
        (array? obj)
        <p> True if the object is a JavaScript Array.
      </dd>
      <dd id="defn-false">
        false
        <p> The canonical "false" value.
            Only <code>false</code>, <code>nil</code>, <code>undefined</code> and
            <code>null</code> are considered false; unlike JavaScript,
            zero, NaN and "" are <i>not</i> considered false.
            Everything else is "true."
      </dd>
      <dd id="defn-true">
        true
        <p> The canonical "true" value.
            Only <code>false</code>, <code>nil</code>, <code>undefined</code> and
            <code>null</code> are considered false; unlike JavaScript,
            zero, NaN and "" are considered true.
            Everything else is "true."
      </dd>
      <dd id="defn-intern">
        (intern "str")
        <p> Returns a Scheme atom named "str".
      </dd>
      <dd id="defn-define">
        (define a form)
        <p> Defines a global-scope variable <i>a</i> with the evaluated value of <i>form</i>.</p>
        (define (fn param...) form ...)
        <p> Defines a global-scope function <i>fn</i> with parameters <i>param...</i>
            which evaluates the forms in the context of the bound parameters.
      </dd>
      <dd id="defn-compile">
        (compile (fn param...) form ...)
        <p> Compiles and defines a global-scope function <i>fn</i> with parameters <i>param...</i>
            which evaluates the forms in the context of the bound parameters.
      </dd>
      <dd id="defn-delete">
        (delete a b)
        <p> Deletes property or array element <i>b</i> from JavaScript object <i>a</i>.
      </dd>
      <dd id="defn-eval">
        (eval form [scope])
        <p> Evaluates <i>form</i> in the given <i>scope</i>.
            Default is the scope of the caller.
      </dd>
      <dd id="defn-eval-string">
        (eval-string "str" [scope])
        <p> Parses and evaluates <i>"str"</i> in the given (optional) <i>scope</i>.
            Default scope is the caller's.
      </dd>
      <dd id="defn-@">
        (@ obj n)
        <p> References element <i>n</i> of JavaScript array <i>obj</i>.</p>
        (@ obj "name")
          <p> References member <i>n<name/i> of JavaScript object <i>obj</i>.
      </dd>
      <dd id="defn-@?">
        (@? obj n)
        <p> References element <i>n</i> of JavaScript array <i>obj</i> if <i>obj</i> is not null
            or undefined, otherwise returns undefined.</p>
        (@"" obj "name")
        <p> References member <i>n<name/i> of JavaScript object <i>obj</i> if <i>obj</i> is not null
            or undefined, otherwise returns undefined.
      </dd>
      <dd id="defn-@!">
        (@! obj "member" ... params)
        <p> Invokes member function <i>member</i> in JavaScript object <i>obj</i>. E.g.</p>
        (@! Math "sin" (/ *pi* 4))
      </dd>
      <dd id="defn-@=">
        (@= obj "member" value)
        <p> Assigns <i>value</i> to JavaScript member <i>member</i> in object <i>obj</i>.
      </dd>
      <dd id="defn-lambda">
        (\ (p1 p2 ...) form ...)
        <p> Returns a closure that binds parameters <i>p1</i>, <i>p2</i>, etc. to the arguments,
            then evaluates the <i>form</i>s sequentially, returning the value of the last one or
            <i>nil</i> if there are none
      </dd>
      <dd id="defn-not">
        (! value)
        <p> Logical "not." Returns <i>true</i> if <i>value</i> is not true.
            "False" values are
            <code>false</code>, <code>nil</code>, <code>undefined</code> and
            <code>null</code>; unlike JavaScript,
            zero, NaN and "" are <i>not</i> considerd false.
            Everything else is "true."
      </dd>
      <dd id="defn-eqv">
        (== a b ...)
        <p> Returns true if all the values are equal to each other.
            Evaluation ends when two items are different.
      </dd>
      <dd id="defn-ne">
        (!= a b ...)
        <p> Returns true unless all the values are equal to each other.
            Evaluation ends when two items are different.
      </dd>
      <dd id="defn-lt">
        (< a b ...)
        <p> Returns true if each value is less than the previous.
            Evaluation ends as soon as this is not the case.
      </dd>
      <dd id="defn-le">
        (<= a b ...)
        <p> Returns true if each value is less than or equal to the previous.
            Evaluation ends as soon as this is not the case.
      </dd>
      <dd id="defn-gt">
        (> a b ...)
        <p> Returns true if each value is greater than the previous.
            Evaluation ends as soon as this is not the case.
      </dd>
      <dd id="defn-ge">
        (> a b ...)
        <p> Returns true if each value is greater than or equal the previous.
            Evaluation ends as soon as this is not the case.
      </dd>
      <dd id="defn-quote">
        'a
        <br>
        (quote a)
        <p> Prevents <code>a</code> from being evaluated and returns it literally.
      </dd>
      <dd id="defn-!==">
        (!== a b ...)
        <p> Reuurns false unless all values are === in the JavaScript sense.
            Evaluation ends as soon as any items are unequal.
      </dd>
      <dd id="defn-===">
        (=== a b ...)
        <p> Returns true if all values are === in the JavaScript sense.
            Evaluation ends as soon as any items are unequal.
      </dd>
      </dd>
      <dd id="defn-if">
        (? predicate true-expr false-expr)
        <p> If the predicate is true,
            (any value other than <code>false</code>, <code>undefined</code>, <code>null</code> or <code>nil</code>),
            evaluates and returns <code>true-expr</code>; otherwise evaluates and returns <code>false-expr</code>.
        <p> "?" can be partially-evaluated. <code>(? true)</code> results in a closure that evaluates
            and returns its first argument; <code>(? false)</code> results in a closude that evaluates and
            returns its second argument.
      </dd>
      <dd id="defn-nullish">
        (?? form ...)
        <p> Evaluates the series of forms, returning the first which is neither null or undefined.
            Evaluation ends as soon as a value is returned.
      </dd>
      <dd id="defn-defn-@?!"> See implementation. </dd>
      <dd id="defn-@@"> See implementation. </dd>
      <dd id="defn-@?!"> See implementation. </dd>
      <dd id="defn-@@!"> See implementation. </dd>
      <dd id="defn-@@="> See implementation. </dd>
      <dd id="defn-@@?"> See implementation. </dd>
      <dd id="defn-@@?!"> See implementation. </dd>
      <dd id="defn-@@@"> See implementation. </dd>
      <dd id="defn-@@@!"> See implementation. </dd>
      <dd id="defn-@@@="> See implementation. </dd>
      <dd id="defn-@@@?"> See implementation. </dd>
      <dd id="defn-@@@?!"> See implementation. </dd>
      <dd id="defn-in"> See implementation. </dd>
      <dd id="defn-Array"> Array <p> The JavaScript Array class. </dd>
      <dd id="defn-Boolean"> Boolean <p> The JavaScript Boolean class. </dd>
      <dd id="defn-Number"> Number <p> The JavaScript Number class. </dd>
      <dd id="defn-BigInt"> BigInt <p> The JavaScript BigInt class. </dd>
      <dd id="defn-String"> String <p> The JavaScript String class. </dd>
      <dd id="defn-Object"> Object <p> The JavaScript Object class. </dd>
      <dd id="defn-Symbol"> Symbol <p> The JavaScript Symbol class. </dd>
      <dd id="defn-mapcar">
        (mapcar fn list...)
        <p> Returns a list of results of <code>fn</code> applied to each element
            of the given lists (or JavaScript iterables such as JavaScript Arrays).
      </dd>
      <dd id="defn-filter">
        (filter predicate-fn list...)
        <p> Returns a list of elemenys of the given lists
            (or JavaScript iterables) where the <code>predicate-fn</code> applied to the
            element is true.
      </dd>
      <dd id="defn-array-map">
        (array-map fn list...)
        <p> Returns a JavaScript Array of results of <code>fn</code> applied to each element
            of the given lists (or JavaScript iterables such as Arrays).
      </dd>
      <dd id="defn-atom?">
        (atom? a)
        <p> Returns true if <code>a</code> is an atom.
      </dd>
      <dd id="defn-finite?">
        (finite? a)
        <p> Returns true if <code>a</code> is neither infinite or a NaN.
      </dd>
      <dd id="defn-gensym">
        (gensym [name]))
        <p> Generates a unique Symbol that is not equal to any other object and is not an atom.
            If a string-valued <code>name</code> is provided, that will be the Symbol's "description."
      </dd>
      <dd id="defn-globalThis">
        globalThis
        <p> The JavaScript global scope.
      </dd>
      <dd id="defn-globalScope">
        globalScope
        <p> The SchemeJS global scope.
      </dd>
      <dd id="defn-sort">
        (sort list [beforeFn] [accessFn])
        <p> Sorts <code>list</code> such if <code>beforeFn</code> is applied to elements
            <code>a</code> and <code>b</code>, then <code>a</code> will be before <code>b</code>
            in the sorted list; the default is <code>&lt;</code>.
            The <code>accessFn</code> selects the "key" to be sorted; the default
            is the element itself.
        <p> The "list" can be any iterable JavaScript object, but if it is an Array, the result
            will also be an Array.
      </dd>
      <dd id="defn-nsort">
        (sort list [beforeFn] [accessFn])
        <p> In-place sort: like <code>sort</code>, but modifies the given list or Array.
      </dd>
      <dd id="defn-xxx">
        xxx
        <p> xxx
      </dd>
      <dd id="defn-xxx">
        xxx
        <p> xxx
      </dd>
    </div>
    <script type="module" src="./CloseButton.mjs"></script>
    <script type="text/javascript">
      "use strict";

      const inputElement = document.getElementById('input');
      const outputElement = document.getElementById('output');
      let globalScope, SCHEME_VERSION;
      let SchemeParseError, SchemeSyntaxError, SchemeParseIncompleteError, NIL, originalLoad;
      let varNo = 0, WS, NL;
      const NBSP = '\u00a0', lambdaStr = "\u03BB";
      let traceCompilerCode = true;

      onload = importSchemeAndRunREPL();
      async function importSchemeAndRunREPL() {
        let SchemeJS = await(import("./SchemeJS.mjs"));
        globalScope = SchemeJS.createInstance({
          lambdaStr, readFile, linePrinter, traceCompilerCode,
          reportLoadResult, reportLoadInput, reportSchemeError, reportSystemError
        });
        SCHEME_VERSION = globalScope.VERSION;
        SchemeParseError = globalScope.SchemeParseError;
        SchemeSyntaxError = globalScope.SchemeSyntaxError;
        SchemeParseIncompleteError = globalScope.SchemeParseIncompleteError;
        NIL = globalScope.NIL;
        let loadAtom = globalScope.Atom("load")
        originalLoad = globalScope[loadAtom];
        globalScope[loadAtom] = load;
        WS = globalScope.WS;
        NL = globalScope.NL;
        buildBuiltinHelp(globalScope);

        // The idea here is to let the handleInput exacute after the keypress has been
        // completely processed. "oninput" is nice, but doesn't indicate the "Enter" key.
        inputElement.onkeydown = event => setTimeout(() => handleInput(event.key === 'Enter'), 0);

        // TODO: I'm just looking for selection changes; there's probably a better way
        inputElement.onmousedown = event => setTimeout(() => handleInput(), 0);
        
        inputElement.contentEditable = 'true';
        inputElement.focus();
      }

      // For "load" and "require"
      let capturedInput, loadPath, loadLine, loadLineCount, loadAsyncContent;

      function load(path, noEval = false) {
        doLoad();
        return NIL;
        async function doLoad() {
          let xhr = new Promise((resolve, reject) => {
            let request = new XMLHttpRequest();
            // Bypass the cache.
            //   https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#bypassing_the_cache
            let reqPath = path + ((/\?/).test(path) ? "&" : "?") + (new Date()).getTime()
            request.onload = _ => {
              if (request.status === 200)
                resolve(request.responseText);
              reject(new Error(`Load ${path}, status ${request.status}`));
            };
            request.onerror = event => reject(new Error(`XMLHttpRequest error ${String(event)}`));
            let async = true;
            request.open('GET', reqPath, async);
            request.send(null);
          });
          try {
            let content = await xhr;
            let saveLoadAsyncContent = loadAsyncContent, savePath = loadPath, saveLine = loadLine, saveLoadLineCount = loadLineCount;
            loadAsyncContent = content;
            loadPath = path;
            loadLine = 0;
            loadLineCount = 0;
            let res;
            try {
              res = originalLoad.call(globalScope, path, noEval);
            } finally {
              loadAsyncContent = saveLoadAsyncContent;
              loadPath = savePath;
              loadLine = saveLine;
              loadLineCount = saveLoadLineCount;
            }
          } catch (error) {
            showError(error);
          }
        }
      }

      function readFile(path) {
        let content = loadAsyncContent;
        if (content === undefined) {
          let request = new XMLHttpRequest();
          let reqPath = path + ((/\?/).test(path) ? "&" : "?") + (new Date()).getTime()
          request.onerror = event => reject(new Error(`XMLHttpRequest error ${String(event)}`));
          let async = false;
          request.open('GET', reqPath, async);
          request.send(null);
          if (request.status !== 200)
            throw new Error(`Load ${path}, status ${request.status}`);
          content = request.responseText;
        }
        capturedInput = '';
        return captureInput(loadAsyncContent);
        return null;
        function* captureInput(source) {
          for (let ch of source) {
            // Eat up initial whitespace and newlines so the reported line
            // isn't at the head of whitespace
            if (capturedInput === '') {
              if (ch === '\n') {
                loadLineCount += 1;
                continue;
              }
              if (WS[ch])
                continue;
              loadLine = loadLineCount+1;
            }
            capturedInput += ch;
            if (NL[ch])
              loadLineCount += 1;
            yield ch;
          }
        }
      }

      function reportLoadInput(expr) {
        varNo += 1;
        showInput(capturedInput, loadPath, loadLine, expr, varNo);
        capturedInput = '';
      }

      function reportLoadResult(result, expr) {
        showResult(result, varNo);
      }

      function reportSchemeError(error, expr) {
        showInput(capturedInput, loadPath, loadLine);
        capturedInput = '';
        showError(error);
      }

      function reportSystemError(error, expr) {
        showInput(capturedInput, loadPath, loadLine);
        capturedInput = '';
        showError(error);
      }

      let helpStack = [];

      function showHelp(id) {
        let elts = document.querySelectorAll('div.help');
        for (let e of elts)
          e.style.display = ''; // back to inherited 'none'
        if (!id) {
          helpStack.pop();
          if (helpStack.length > 0)
            helpStack[helpStack.length-1].style.display = 'block';
          return;
        }
        id = id.split("#");
        let frag = id[1];
        id = id[0];
        let helpElement = document.getElementById(id);
        if (helpElement) {
          helpStack.push(helpElement);
          helpElement.style.display = 'block'; // inherits 'none' from "help" class
          let contentElement = helpElement.querySelector('div');
          if (contentElement) {
            contentElement.scrollTop = 0;
            if (frag) {
              let element = contentElement.querySelector(`#${frag}`);
              if (element)
                element.scrollIntoView(true);
            }
          }
        }
      }

      function buildBuiltinHelp(globalScope) {
        const string = globalScope.string;
        let helpGroups = globalScope._helpgroups_, groups = {};
        // Invert by group on atom value
        for (let atom of Object.getOwnPropertySymbols(helpGroups)) {
          let value = globalScope[atom], helpGroup = helpGroups[atom];
          if (value === undefined) continue;
          let groupMap = groups[helpGroup];
          if (!groupMap)
            groupMap = groups[helpGroup] = new Map();
          let valueObj = groupMap.get(value);
          if (!valueObj)
            groupMap.set(value, valueObj = { atoms: [], jsNames: [] });
          valueObj.atoms.push(atom);
        }
        // Add JavaScript names
        for (let jsName of Object.getOwnPropertyNames(helpGroups)) {
          let value = globalScope[jsName], helpGroup = helpGroups[jsName];
          if (value === undefined) continue;
          let groupMap = groups[helpGroup];
          if (!groupMap) continue;
          let valueObj = groupMap.get(value);
          if (!valueObj) continue
          valueObj.jsNames.push(jsName);
        }
        // Organize into a symbol table by group then sort on a transformation of the first
        // atom defined. "groups" is now: groups[groupName] = (sorted)[{ key, atoms: [], jsNames: [] }];
        for (let helpGroup in groups) {
          let groupMap = groups[helpGroup];
          let symtab = [];
          for (let [map_key_which_is_the_value, valueObj] of groupMap.entries()) {
            valueObj.key = keyFor(valueObj.atoms[0]);
            valueObj.value = map_key_which_is_the_value;
            symtab.push(valueObj);
          }
          symtab.sort((a, b) => a.key < b.key ? -1 : 1);
          groups[helpGroup] = symtab;
        }
        for (let helpGroup in groups) {
          let symtab = groups[helpGroup];
          let helpElement = document.getElementById(`helpgroup-${helpGroup}`);
          if (!helpElement) {
            console.error("Missing help group", helpGroup);
            continue;
          }
          for (let { atoms, jsNames, value } of symtab) {
            for (let atom of atoms)
            if (helpGroup === "imported") {
              let anchor = textElement('a', atom.description)
              anchor.setAttribute('href', `https://developer.mozilla.org/docs/Web/API/${atom.description}`);
              let dt = document.createElement('dt');
              dt.appendChild(anchor);
              helpElement.appendChild(dt);
            } else {
              helpElement.appendChild(textElement('dt', atom.description));
            }
            let dd;
            for (let atom of atoms) {
              let elementId = "defn-" + atom.description;
              dd = document.getElementById(elementId);
              if (dd) break;
            }
            if (!dd)
              dd = textElement('dd', `TBD defn-${atoms[0].description}`);
            helpElement.appendChild(dd);
            if (typeof value === 'function') {
              dd.appendChild(textElement('p', string(value), 'impl'));
            } else {
              dd.appendChild(textElement('p', string(value), 'value'));
            }
            if (jsNames.length > 0) {
              let jsNamesElement = textElement('p', '', 'js-names');
              dd.appendChild(jsNamesElement);
              for (let jsName of jsNames)
                jsNamesElement.appendChild(textElement('span', jsName, 'js-name'));
            }
          }
        }

        function keyFor(atom) {
          let key = atom.description, alpha = "abcdefghijklmnopqrstuvwxyz", stripPrefixSyms = "*#!?";
          key = key.toLowerCase();
          // Strip certain special symbols before alpha (mostly for *catch and *throw)
          if (stripPrefixSyms.includes(key[0]) && alpha.includes(key[1]))
            key = key.substr(1);
          // Anything that doesn't begin with an alpha gets sorted to the top (space sorts lowest)
          if (!alpha.includes(key[0]))
            key = ' ' + key;
          return key;
        }

        function textElement(type, text, cls) {
          let element = document.createElement(type);
          element.textContent = text;
          if (cls)
            element.setAttribute('class', cls);
          return element;
        }
      }

      const LOCAL_STORAGE_KEY = `SchemeJS-${location.pathname}`;
      const appVersion = "1.1";
      let persistedState = {};

      function saveState() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        persistedState.version = appVersion;
        let json = JSON.stringify(wad);
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, json);
          return true;
        }
        catch (_) {
        }
        return false;
      }

      function loadState() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        let json = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!json)
          return false;
        let wad;
        try {
          wad = JSON.parse(json);
        } catch (_) {
          //  ¯\_(ツ)_/¯
        }
        if (typeof wad !== 'object')
          return false;
        let appVer = appVersion.split('.'), saveVer = wad.version.split('.');
        if (!(Number(saveVer[0]) <= Number(appVer[0])))  // handles undefined implicitly
          return false;
        persistedState = wad;
        return true;
      }

      document.body.setAttribute('data-protocol', window.location.protocol);

      function toggleDeviceMode(mode) {
        const attr = 'data-device';
        if (mode || !document.body.getAttribute(attr))
          document.body.setAttribute(attr, mode || 'mobile');
        else
          document.body.removeAttribute(attr);
      }

      {
        let styles = window.getComputedStyle(document.body);
        let val = styles.getPropertyValue("--device").trim();
        if (val !== '')
          toggleDeviceMode(val);
      }

      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape')
          showHelp(null);
      });

      let printBoxElement;

      function handleInput(enterKey) {
        let parseContext = [], assignSyntax = true;
        let inputText = getElementText(inputElement);
        // console.log("TEXT", inputText);
        let pos = getSelectionPosition(inputElement);
        for (let span of inputElement.querySelectorAll('span'))
          span.replaceWith(span.textContent);
        inputElement.normalize();
        try {
          function* characterGenerator() {
            let part1 = inputText.substr(0, pos), part2 = inputText.substr(pos);

            // Feed parser part up to the cursor
            for (let ch of part1)
              yield ch;

            // Colorize opening grouping symbols
            let alpha = 1, fade = .6;
            for (let i = parseContext.length; i > 0; --i) {
              let tok = parseContext[i-1], pos = tok.position, width = 1;
              if (typeof tok.value === 'string') width = tok.value.length;
              colorizeCharsAt(inputElement, pos, width, 'match-tokens',
                `background-color: rgba(255, 200, 0, ${alpha}); color: blue`);
              alpha *= fade;
            }

            let depth = parseContext.length;
            alpha = 1;
            // Feed the rest
            for (let ch of part2) {
              yield ch;
              if (parseContext.length < depth) {
                let tok = parseContext.currentToken, pos = tok.position, width = 1;
                if (typeof tok.value === 'string') width = tok.value.length;
                if (tok.endPosition)
                  pos = tok.endPosition;
                if (tok.endWidth)
                  width = tok.endWidth;
                colorizeCharsAt(inputElement, pos, width, 'match-tokens',
                  `background-color: rgba(255, 200, 0, ${alpha}); color: blue;`);
                alpha *= fade;
                depth = parseContext.length;
              }
            }
            insertTextAndSetCursorAfter(inputElement, pos, "");
          }

          // Parse
          let expr = globalScope.parseSExpr(characterGenerator(), { parseContext, assignSyntax });

          if (!(enterKey && pos === inputText.length))
            return; // TODO: auto-indent the line-break

          let loadPath = null, loadLine = null;
          inputElement.textContent = '';
          ++varNo;
          showInput(inputText, loadPath, loadLine, expr, varNo);

          // Eval
          let value = globalScope.eval(expr, globalScope);

          // Show results and save in variables for later reuse
          showResult(value, varNo);
        } catch (error) {
          if (error instanceof SchemeParseError) {
            if (!(error instanceof SchemeParseIncompleteError))
              // console.log("SchemeParseError", error);
            if (error instanceof SchemeSyntaxError) {
              let position = error.position;
              colorizeCharsAt(inputElement, position, inputText.length - position, 'error-tokens');
            }
            let indent = "";
            if (enterKey && parseContext.currentToken?.type !== 'string' && parseContext.length > 0)
              indent =  NBSP.repeat(parseContext[parseContext.length-1].lineChar + 2);
            insertTextAndSetCursorAfter(inputElement, pos, indent);
          } else {
            showError(error);
          }
        }
      }

      function showInput(inputText, path, line, expr, varNo) {
        // Show results and save in variables for later reuse
        inputText = trimEndNewlines(inputText);
        let div = document.createElement('div');
        div.setAttribute('class', 'input-box');
        if (varNo != null && expr !== undefined) {
          let span = document.createElement('span');
          span.setAttribute('class', "tag");
          let name = `?${varNo}`;
          globalScope[globalScope.Atom(name)] = expr;
          span.textContent = name;
          div.appendChild(span);
        }
        let innerDiv = document.createElement('div');
        innerDiv.setAttribute('class', 'input-scroller');
        if (path != null) {
          let pathElement = document.createElement('div');
          pathElement.setAttribute('class', 'load-path');
          pathElement.textContent = `${path}, line ${line}:`;
          innerDiv.appendChild(pathElement);
        }
        for (let pgf of convertToHTMLContent(inputText, 'text'))
          innerDiv.appendChild(pgf);
        div.appendChild(innerDiv);
        outputElement.appendChild(div);
        div.scrollIntoView();
      }

      function trimEndNewlines(str) {
        while (NL[str[str.length-1]])
          str = str.substr(0, str.length-1);
        return str;
      }

      function showResult(value, varNo) {
        if (printBoxElement)
          printBoxElement = undefined;
        let div = document.createElement('div');
        div.setAttribute('class', 'result-box');
        if (varNo != null) {
          let span = document.createElement('span');
          span.setAttribute('class', "tag");
          let name = `=${varNo}`;
          globalScope[globalScope.Atom(name)] = value;
          span.textContent = name;
          div.appendChild(span);
        }
        let innerDiv = document.createElement('div');
        innerDiv.setAttribute('class', 'result-scroller');
        let evaluatedString = globalScope.string(value);
        for (let pgf of convertToHTMLContent(evaluatedString, 'text'))
          innerDiv.appendChild(pgf);
        div.appendChild(innerDiv);
        outputElement.appendChild(div);
        div.scrollIntoView();
      }

      function linePrinter(line) {
        if (!printBoxElement) {
          printBoxElement = document.createElement('div');
          printBoxElement.setAttribute('class', 'print-box');
        }
        let innerDiv = document.createElement('div');
        innerDiv.setAttribute('class', 'print-scroller');
        for (let pgf of convertToHTMLContent(line+'\n', 'text'))
          innerDiv.appendChild(pgf);
        printBoxElement.appendChild(innerDiv);
        outputElement.appendChild(printBoxElement);
        printBoxElement.scrollIntoView();
      }

      function showError(error) {
        console.error("Error", error);
        let errorElement = document.createElement('div');
        errorElement.setAttribute('class', 'error-box');
        errorElement.textContent = String(error)
        outputElement.appendChild(errorElement)
        errorElement.scrollIntoView();
      }

      function convertToHTMLContent(text, cls) {
        let divs = [], line = '';
        for (let ch of text) {
          if (NL[ch]) {
            addDiv(line);
            line = '';
          }
          if (WS[ch])
            ch = NBSP;
          line += ch;
        }
        if (line !== '')
          addDiv(line);
        return divs;
        function addDiv(line) {
          let element = document.createElement('div');
          if (cls)
            element.setAttribute('class', cls);
          element.textContent = line.replaceAll(' ', NBSP);
          if (line === '')
            element.appendChild(document.createElement('br'));
          divs.push(element);
        }
        return res;
      }

      function getSelectionPosition(editableElement) {
        let selection = window.getSelection();
        // console.log("SEL", selection.anchorNode, selection.anchorOffset, selection);
        if (!selection) return undefined;
        let anchorNode = selection.anchorNode;
        let selectionPosition = selection.anchorOffset;
        if (!editableElement.contains(anchorNode)) return undefined;
        traverseEditableElement(editableElement, onNode);
        // console.log("POS", selectionPosition);
        return selectionPosition;
        function onNode(node, pos, isNewline) {
          // console.log ("GSP", pos, node.tagName, node.data);
          if (node === anchorNode) {
            selectionPosition += pos;
            return true;
          }
        }
      }

      function getElementText(element) {
        let text = '';
        traverseEditableElement(element, onNode);
        // Parser recognizes NBSP as whitespace but know that they're there!
        // text = text.replaceAll(NBSP, ' ');
        // console.log("GET", text);
        return text;
        function onNode(node, pos, isNewline) {
          if (isNewline)
            text += '\n';
          if (node instanceof Text)
            text += node.data;
        }
      }

      function insertTextAndSetCursorAfter(element, insertPosition, text = '') {
        // console.log("ISC", insertPosition, text);
        let selection = window.getSelection();
        if (!selection) return false;
        return traverseEditableElement(element, onNode);
        function onNode(node, pos, isNewline) {
          let localPos = insertPosition - pos;
          // console.log ("ITA", localPos, node.tagName, node.data);
          if (localPos < 0) return;
          if (node instanceof Text) {
            // console.log ("ITA TEXT");
            let content = node.data;
            if (localPos <= node.data.length) {
              if (text !== '') {
                content = content.substr(0, localPos) + text + content.substr(localPos);
                node.textContent = data;
              }
              selection.collapse(node, localPos);
              return true;
            }
          } else if (node instanceof Element) {
            if (localPos < 0) return false;
            if (localPos === 0) {
              // console.log ("ITA ELEMENT");
              let textNode = document.createTextNode(text);
              if (node.tagName === 'BR' && node.parentElement.tagName === 'DIV') {
                node.replaceWith(textNode);
              } else {
                node.prepend(textNode);
                selection.collapse(textNode, text.length);
              }
              return true;
            }
          }
        }
      }

      function colorizeCharsAt(element, colorizePosition, nchar, cls, style) {
        // console.log("COLORIZE!", colorizePosition, nchar, cls, style);
        return traverseEditableElement(element, onNode);
        function onNode(node, pos, isNewline) {
          let localPos = colorizePosition - pos;
          // console.log("COLORIZE", localPos, node.tagName, node.data);
          if (localPos < 0) return;
          if (node instanceof Text) {
            let text = node.data;
            if (localPos < text.length) {
              let before, replace, after, n = nchar;
              if (n > text.length - localPos)
                n = text.length - localPos;
              if (localPos === 0) {
                replace = node;
                if (n < text.length)
                  after = node.splitText(n);
              } else {
                before = node;
                replace = node.splitText(localPos);
                if (n < replace.textContent.length)
                  after = replace.splitText(n);
              }
              let highlightElement = document.createElement('span');
              highlightElement.textContent = replace.textContent;
              if (cls)
                highlightElement.setAttribute('class', cls);
              if (style)
                highlightElement.setAttribute('style', style);
              node.parentElement.replaceChild(highlightElement, replace);
              nchar -= n;
              colorizePosition += n;
              if (nchar <= 0) return true;
            }
          }
        }
      }

      function traverseEditableElement(editableElement, onNode) {
        let pos = 0;
        return traverse(editableElement);
        function traverse(node) {
          let isReturn = false;
          if (node.parentElement === editableElement && node.previousSibling && node.tagName === 'DIV') {
              pos += 1;
              isReturn = true;
          }
          if (node !== editableElement) {
            let res = onNode(node, pos, isReturn);
            if (res !== undefined) return res;
          }
          if (node instanceof Element) {
            for (let child of node.childNodes) {
              let res = traverse(child);
              if (res !== undefined) return res;
            }
          } else if (node instanceof Text) {
            pos += node.data.length;
          }
        }
      }

      function runUnitTests() {
        runTests();
        async function runTests() {
          let traceCompilerCode = true;
          let UnitTest = await(import("./UnitTest.mjs"));
          UnitTest.run({ throwOnError: false, traceCompilerCode });
        }
      }

      if ('serviceWorker' in navigator && window.location.protocol === 'https:')
        navigator.serviceWorker.register('service-worker.js');

      try { loadState(); } catch (e) {} // inconvenient to crash while loading
   </script>
  </body>
</html>