<!DOCTYPE html>
<!--
  SchemeJS: Scheme in JavaScript

  Copyright 2021 Stan Switzer -- (sjswitzer [at] gmail [dot] com)
    This work is licensed under a Creative Commons Attribution-ShareAlike
    4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/
-->
<html>
  <head>
    <title>SchemeJS: Scheme in JavaScript</title>
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="viewport" content="width=device-width">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <meta name="format-detection" content="telephone=no">
    <link rel="apple-touch-icon" href="icon128.png">
    <link rel="manifest" href="manifest.webmanifest">
    <base target="_blank"> <!-- all links open in a new tab/page -->
    <style type="text/css">
      /*
       * If there's a vaguely 60's aesthetic to this UI,
       * consider that it might be deliberate. :)
       */
      html {
        -webkit-text-size-adjust: none
      }

      * { /* input elements lay out bizarrely without this since their borders aren't part of their size */
        box-sizing: border-box;
      }

      body {
        padding: .2em .5em;
        margin: 0em 0em;
        background-color: #f8f8f8;
        text-size-adjust: none;   /* keep mobile browsers from getting sneaky with sizing */
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
      html, table  {
        font: 100% caption, sans-serif;
      }

      /*
       * Initially-hidden help content.
       * Help contains a custom <close-button> and
       * a <div> for help content which is made scrollable.
       */
      div.help {
        padding: 0;
        background-color: #e8e8e8;
        position: absolute;
        display: none;
        top: 10%;
        left: 45%;
        right: .5em;
        bottom: .5em;
        border: .15em solid black;
        border-radius: .5em;
        overflow: hidden;  /* so that scrolled text stays bounded to this box */
      }
      div.help > * {
        margin: 0 1em;
      }
      div.help > .top {
        margin: 0 0;
        padding: 0 1em .5em 1em;
        border-bottom: .05em solid black;
      }
      div.help > close-button {
        z-index: 1;
        color: #0005;  /* rather transparent black */
        font-size: 150%;
        --close-button-x-thick: 35%;
        position: absolute;
        top: .3em;
        right: .3em;
        transition: .25s;
      }
      div.help > close-button:hover {
        font-size: 160%;
        color: black;
      }
      div.help > .help-content {
        overflow-y: auto;
        height: 100%;
      }

      .help dl,
      .help dl dt,
      .help dl dd {
        display: block;
        /*
         * "overflow:auto" creates a "block formatting context" while "dislpay:block" does not!
         * I *think* "contain: paint" is more sensible, though, but only seems to work in Chrome.
         * Look up "CSS block formatting context." It's wild!
         * The block formatting context determines the box that "float" items float within.
         */
        overflow: auto;
        contain: paint;
      }
      .help dl {
        margin: .25em 0 .25em 0;
      }
      .help dl dt {
        float: left;
        clear: right;
        margin-inline-end: 1ch;
      }
      .help dl dd {
        float: right;
        margin-inline-start: unset;
        --definition-margin: 11ch;
        --definition-percent: 80%;
        width: max(var(--definition-percent), calc(100% - var(--definition-margin)));
      }
      .help dl dd,
      .help dl dt {
        padding-top: .5em;
      }
      .help dl .heading {
        font-weight: bold;
        font-style: normal !important;
      }
      .help dd p {
        margin: .5em 0 .5em 0;
      }

      .help dl p.impl,
      .help dl p.value {
        color: #555;
      }

      .help .impl:before { content: "Impl: " }
      .help .value:before { content: "Value: " }
      .help .js-names:before { content: "JavaScript: " }
      .help .js-name { padding-right: .5em; }
      .help .impl, .help .value, .help .js-names { display: none }
      div[data-show-impl="true"] .impl, div[data-show-impl="true"] .value { display: block; }
      div[data-show-javascript="true"] .js-names { display: block; }

      dl#helpgroup-js-op dd .tbd {
        display: none;
      }
      dl#helpgroup-js-op dd .impl {
        display: inline !important;
      }

      #helpgroup-imported dl {
        display: block;
      }
      #helpgroup-imported dt {
        display: span;
        font-style: italic;
      }
      #helpgroup-imported dd {
        display: none;
      }

      .help .example {
        font-style: italic;
      }

      .help .definitions dd {
        font-style: italic;
      }
      .help .definitions dd p {
        font-style: normal;
      }

      #help-details dl dd {
        --definition-margin: 5ch;
      }

      .help ul {
        padding-left: 1.25em;
      }
      .help ul > li {
        margin: .5em;
      }

      code {
        font-style: italic;
        font-family: caption, sans-serif;
      }

      /*
       * Makes a <span> into a "button"
       */
      span.button {
        display: inline-block;
        cursor: pointer;
        padding: .2em .6em;
        background: #44f;
        border-radius: .5em;
        color: white;
      }
      span.button:hover {
        background: #0000dd;
      }
      span.button:active {
        background: #0000cc;
      }
      span.padded-button {
        padding: .2em 1.5ch;
      }

      /* greasy way to make a text-delete button in the input box */
      .clear-text-button {
        position: relative;
        width: 0;
      }
      .clear-text-button > close-button {
        position: absolute;
        bottom: .15em;
        left: -2em;
        color: white;
        --close-button-box-color: #8e8d92;
        --close-button-box-radius: 50%;
        --close-button-x-thick: 25%;
        --close-button-x-size: 55%;
        padding: .05em .4em;
      }

      /* Looks like a link but is actually a "button" */
      span.linklike {
        color: #00d;
        cursor: pointer;
        text-decoration: underline;
      }

      #container {
        display: flex;
        flex-flow: column nowrap;
        overflow: hidden;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: 0;
        padding: .25em .25em .25em .25em;
      }

      #header {
        display: flex;
        flex-flow: row nowrap;
        flex: 0 10 auto;
        width: 100%;
        font-size: 160%;
      }

      #header #title {
        flex: 1 0 auto;
        align-self: flex-end;
      }
      #lambda {
        font-size: 150%;
        margin-right: .15em;
      }

      #header #about {
        flex: 0 0 auto;
      }

      #output, #input { font: 90% Lucida Console, Monaco, Consolas, Courier New, monospace; }

      /* Mobile tweeks; unnecessary CSS selectors to increase match priority */
      @media (hover: none) {
        html body #input {
          font-size: 110%;  
          flex-basis: 4em;
        }
        html body #header {
            font-size: 120%;
        }
      }
      @media (hover: none) and (orientation:portrait) {
        html body #header {
          font-size: 100%;
        }
        html body #input {
          flex-basis: 6em;
        }
        html body .help {
          left: 20%;
        }
      }
      @media not all and (hover: none) {
        body #about { font-size: 80%; }
      }

      #output {
        /* https://geon.github.io/programming/2016/02/24/flexbox-full-page-web-app-layout */
        flex: 1 1 25em;
        overflow: scroll;
        justify-content: flex-end;
        margin-top: 0.1em;
        padding: .15em .15em .15em .15em;
        width: 100%;
        background-color: #ccc;
        border: .1em solid;
        border-radius: .5em;
      }
      #output .input-box, #output .result-box, #output .print-box, #output .error-box {
        position: relative;  /* so that the "tag"" can be positioned absolutely */
        justify-self: end;
        margin-top: 0.25em;
        border: .1em solid;
        border-radius: .5em;
      }
      #output .tag {
        position: absolute;  /* parent div must be position: relative */
        opacity: .5;
        top: 0;
        right: 0;
        margin: 0.3em 0.3em 0 0;
        padding: 0.1em 0.25em 0.1em 0.25em;
        font-size: 90%;
        border: .1em solid;
        border-radius: .5em;
        background-color: #ddd;
      }
      #output .input-scroller, #output .result-scroller, #output .print-scroller {
        overflow: scroll;
        min-height: 2em;
      }
      #output .result-scroller {  max-height: 20em; }
      #output .print-scroller {  max-height: 100em; }
      #output .result-scroller { padding: .5em .5em .5em .5em }
      #output .error-box { padding: .5em .5em .5em .5em }
      #output .input-scroller { padding: 0 0 .5em 0 }
      #output .input-scroller .text { margin: 0 .5em 0 .5em }
      #output .input-scroller .text:first-child { margin-top: .5em }
      #output { background-color: #eeeeee }
      #output .input-box { background-color: #ffffff }
      #output .result-box { margin-left: 1em; background-color: #f8f8f8 }
      #output .error-box { margin-left: 1em; background-color: #ffbbbb }
      #output .print-box { margin-left: 1em; background-color: #ffffcc }
      #output .load-path {
        margin-bottom: .5em;
        padding: .25em;
        background-color: #d6d6fd;
        border-radius: .5em .5em 0 0;
       }

      /* The input box */
      #input {
        flex: 0 0 6em;
        margin-top: 0.25em;
        padding: .5em .5em .5em .5em;
        width: 100%;
        border: .1em solid;
        border-radius: .5em;
        background-color: #ffffff;
      }
      #input .match-tokens {
        border-radius: .5em;
      }
      #input .error-tokens {
        background-color: rgb(252, 124, 124);
      }

      /* canvas support */
      .canvas-frame .title-bar { font: 90% Lucida Console, Monaco, Consolas, Courier New, monospace; }
      .canvas-frame .title-bar close-button {
        --close-button-box-color: #f77;
        --close-button-x-thick: 25%;
        --close-button-x-size: 65%;
        color: white;
        vertical-align: -20%;
        transition: .5s;
        transition-property: --close-button-box-color;
        margin-right: 1ch;
      }
      .canvas-frame .title-bar close-button:hover {
        --close-button-box-color: #f00;
      }
      .canvas-frame .title-bar {
      }
      .canvas-frame {
        display: flex;
        flex-flow: column nowrap;
        position: absolute;
        background-color: #ddd;
        border: .1em solid;
        border-radius: .5em;
        padding: 5px;
      }
      .drawing-canvas {
        background-color: white;
      }
    </style>
  </head>
  <body id="body">
    <div id="container">
      <div id="header">
        <div id="title"><span id="lambda">&lambda;</span> SchemeJS: Scheme in JavaScript</div>
        <div id="about">
          <span class="button" onclick="showHelp('help-about')"> ? </span>
        </div>
      </div>
      <div id="output"></div>
      <div id="input" spellcheck="false" autocomplete="off" spellcheck="false" autocorrect="off"
          autocapitalize="none"></div>
    </div>
    <input type="file" style="display:none" id="load-file-dialog" accept=".scm">
    <div class="help" id="help-about">
      <close-button onclick="showHelp(null)"></close-button>
      <div class="help-content">
        <h2> SchemeJS: Scheme in JavaScript </h2>
        <p> JavaScript has dynamic typing, functions, closures, and a JIT with
            a small army of crack programmers optimizing its performance.
            It’s an ideal runtime for Scheme.
            All it lacks is cons cells, an s-expression parser/printer,
            eval/apply, and a handful of Lisp primitives.
        <p> Oh, and a compiler and JIT that compiles Scheme down to perfectly normal
            JavaScript functions that JavaScript JITs can go to town on.
        <p> SchemeJS fills that gap.
        <p> It’s hard to keep JavaScript objects from sneaking into the
            SchemeJS world, so I decided to invite them in as first-class.
            SchemeJS is fully Scheme <i>and</i> fully JavaScript.
        <p> This implementation aims for broad compatibility with SIOD, but inevitably,
            and in the grand tradition of lisp implementations, introduces a new dialect.
            Which is a sin but not a crime.
        <p> Run a demo by typing <code>(load "demo.scm")</code>
            and <code>(load "gfxdemo,scm")</code>.
        <p> Learn about
            <span class="linklike" onclick="showHelp('help-builtin')"">built-in Scheme definitions</span> and
            <span class="linklike" onclick="showHelp('help-details')"">implementation details</span>.
      </div>
    </div>
    <div class="help" id="help-details">
      <close-button onclick="showHelp(null)"></close-button>
      <div class="help-content">
        <h2> Implementation Details </h2>
        <p>
        <h3> Key Features </h3>
        <h4> JavaScript Integration and Interoperability</h4>
        <p> SchemeJS and JavaScript have full and fluent access to each other's objects.
            SchemeJS can call invoke any JavaScript function and every SchemeJS
            function is a JavaScript function, <i>whether it is compiled or not</i>.
        <p> Syntax for JavaScript Object and Array literals.
        <p> Core SchemeJS primitives are implemented directly on fundamental
            JavaScript primitives such as function closures and prototype resolution.
            These are the things that JavaScript JITs optimize most thouroughly.
        <h4> Iterable-Aware </h4>
        <p> SchemeJS lists are iterable in JavaScript and JavaScript iterables can be
            viewed as Scheme lists, either immediately or lazily.
        <p> SchemeJS built-in functions that operate on lists also operate on any JavaScript
            iterable such as Arrays.
        <h4> N-ary Comparisons </h4>
        <p> Comparison functions such as "<" can be applied to arbitrarily many arguments. In this case
            it means that each argument is less than the previous. Evaluation ends as soon as
            the comparison fails.
        <h4> Partial Function Application </h4>
        <p> Functions, whether user-defined, compiled, or implemented in JavaScript, when
            invoked with fewer than their required number of parameters, result
            in a <i>closure</i> that binds the given arguments.
            For instance, <code>(+ 5)</code> results in a function (closure) that
            adds 5 to its argument(s).
        <p> Because the expression <code>(< 10)</code> evaluates to a function that's
            true if 10 is less than its argument, the expression
            <code>(filter (< 10) list)</code> returns a new list with elements from <code>list</code>
            that are ten or greater. (Seems backwards, perhaps, but that's Scheme for ya.)
        <h4> Generalized Special Forms </h4> 
        <p> Users can define "special forms" that take a specified number of evaluated parameters;
            the rest are unevaluated.
            In <code>(\# 2 (a1 a3 a3 a5) forms...)</code>, <i>a1</i> and <i>a2</i> are evaluated and the rest are not.
        <h4> Optional Parameters </h4>
        <p> A function defined as <code>(define (fn p1 (? p2 expr) (? p3 expr) ) form ...)</code>
            has optional parameters <code>p2</code> and <code>p3</code> with default values
            supplied by the expressions that follow them. The expressions are evaluated only
            if the parameter is absent.
        <h4> Rest Parameters </h4>
        <p> A function defined as <code>(define (fn p1 p2 . p3) form ...)</code> takes two
            normal parameters (<i>p1</i> and <i>p2</i>) and receives a third parameter <i>p3</i>,
            that recieves a list of the remaining arguments.
        <p> Similarly, a lambda of the form <code>(&lambda; (p1 p2 . p3) form ...)</code> has a
            rest parameter <i>p3</i>.
        <h4> Curry Notation </h4>
        <p> If you like Curry notation, go ahead and use it!
            <code>(&lambda;x.(+ x 2))</code>. The evaluator, compiler and printer
            all understand it.
        <h4> Predicates as Conditionals </h4>
        <p> Predicates such as <code>number?</code> can be used to test a value's type
            and return a boolean, or as conditionals themselves.
        <h4> Lazy Lists and Map Functions </h4>
        <p> JavaScript iterators can be turned into lazy cons cells that don't fetch
            the next object until <i>cdr</i> is invoked.
        <p> Lazy "map" is the same, but in addition the mapping function is not applied
            until <i>car</i> is invoked on the mapped list.
        <h4> Compiler </h4>
        <p> A compiler (a "transpiler," technically, but that sounds silly)
            that transforms Scheme into perfectly normal JavaScript that the
            JIT can go to town on.
        <p> An optional JIT that kicks in after a client-selectable number of invocations
            of a function. Because a JIT necessarily <i>binds</i> the current definitions
            of functions referenced in the compiled code, JIT-compiled code contains
            a <i>guard</i> that ensures those bindings have not changed and bails to the
            interpreter if they have. The function is then elligible to be JITted again
            if invoked sufficiently often.
        <h4> Easly Embedded </h4>
        <p> SchemeJS is a JavaScript module designed to be easily embedded into other applications.
            Scheme JS can run in any web page (in a sufficiently modern browser; even on mobile devices)
            and can do anything JavaScript can do with as few as a half dozen lines of code to import it.
        <p> It comes with a Node.js-based CLI/REPL and this web-based REPL but
            they're just simple embeddings of the SchemeJS runtime.
        <p> SchemeJS has <i>no dependencies</i> beyond a modern JavaScript runtime.
        <h4> Unicode </h4>
        <p> SchemeJS identifiers can use any Unicode "alphabetic" characters (including ideographs).
            People should be able to program in their own languages.
        <h3> Sundry </h3>
        <p> <span class="linklike" onclick="runUnitTests()">Run unit tests</span>; results
            display in the browser console. This Web REPL curently configures
            the runtime to log compiled code to the console.
            You can also see the compiled code of a funtion by typing
            <code>(println (String fn))</code>.
        <p> Copyright &copy; 2021, Stan Switzer &mdash; (sjswitzer [at] gmail [dot] com)
        <div style="width: 100%">
          This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            Creative Commons Attribution-ShareAlike 4.0 International License</a>.
          <br> Find source on
          <a href="https://github.com/sjswitzer/SchemeJS">GitHub</a>
          <p></p>
        </div>
      </div>
    </div>
    <div class="help" id="help-builtin">
      <close-button onclick="showHelp(null)"></close-button>
      <div class= "top"">
        <h2 style="margin-bottom:.25em"> Built-In Functions and Constants </h2>
        <input type="checkbox" name="impl"
          onchange="parentElement.parentElement.setAttribute('data-show-impl', String(event.currentTarget.checked))">
        <label for="javascript">Implementations</label> &nbsp;
        <input type="checkbox" name="javascript"
          onchange="parentElement.parentElement.setAttribute('data-show-javascript', String(event.currentTarget.checked))">
        <label for="javascript">JavaScript API</label>
      </div>
      <div class="help-content">
        <h3> Core Operations</h3>
        <dl class="definitions" id="helpgroup-core">
          <dt class="heading"> Symbol
            <dd class="heading"> Description

          <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> N-Ary Operations </h3>
        <dl class="definitions" id="helpgroup-var-op">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Bitwise Operations </h3>
        <p> Other bitwise operations are listed avove under N-Ary Operations.
        <dl class="definitions" id="helpgroup-bitwise-op">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Comparison Operations </h3>
        <p> These operations take an arbitrary number of arguments and return false,
            ending evaluation, as soon as the relation fails to hold between successive elements.
        <dl class="definitions" id="helpgroup-compare-op">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h3> Logical Operations </h3>
        <dl class="definitions" id="helpgroup-logical-op">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h2> List Operations </h2>
        <dl class="definitions" id="helpgroup-list-op">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h2> Predicate Conditional Operations </h2>
        <p> These operations can function as simple predicates, returning <code>true</code> or
            <code>false</code>, or as conditional operations, evaluating the second argument
            if true and the third if false. You were probably going to us it for a condition anyway.
            (Actually, it <i>always</i> evaluates and returns the second or third argument; it's just that
            their default values are <code>true</code> and <code>false</code>.)
        <dl class="definitions" id="helpgroup-pred-op">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h2> JavaScript-Related Operations </h2>
        <p> The implementations should explain what they do well enough.
        <dl class="definitions" id="helpgroup-js-op">
          <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h2> Sundry </h2>
        <dl class="definitions" id="helpgroup-default">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
        <h2> Functions and Constants Imported from JavaScript </h2>
        <dl class="definitions" id="helpgroup-imported">
           <!-- definitions inserted here when SchemeJS module is loaded -->
        </dl>
      </div>
    </div>
    <!-- These definitions get moved into the help section at startup -->
    <div style="display: none !important">
      <dd id="defn-*catch">
        (*catch "tag" form ...)
        <p> SIOD-style catch.
            Evaluates the forms until one of them calls
            <code>(*throw "tag" value)</code>.
            Returns "value" if the tags match; otherwise the exception propagates.
      </dd>
      <dd id="defn-*throw">
        (*throw "tag" value)
        <p> SIOD-style throw.
            Throws the value with the given tag.
            An enclosing <code>(*catch "tag" form ...)</code> will
            return "value" if the tags match; otherwise the exception propagates.
      </dd>
      <dd id="defn-catch">
        (catch catch-clause forms)
        <p> where <i>catch-clause</i> is:</p>
        (error type forms)
        <p> Java/JavaScript-style catch.
        <p> Evaluates the forms until one of them calls <code>(throw obj)</code>.
            If the <i>type</i> matches the thrown object,
            the <i>catch-clause</i> forms are evaluated with the thrown object bound
            to "<i>error</i>".
            If <i>type</i> is an object, the catch matches if the object is an instance
            of that object; it <i>type</i> is a string, the catch matches if it is the JavaScript
            "typeof" the thrown object.
      </dd>
      <dd id="defn-throw">
        (throw "tag" value)
        <p> Java/JavaScript-style-style throw.
            Throws the value with the given tag.
            An enclosing <code>(*catch "tag" form ...)</code> will
            return "value" if the tags match; otherwise the exception propagates.
        <p> For example:
        <p class="example">
            (catch (e "string" (+ "thrown: " e))<br>
            &nbsp;&nbsp; (+ 1 2)<br>
            &nbsp;&nbsp;  (+ 3 (throw "ha ha!"))<br>
            )
      </dd>
      <dd id="defn-*e*">
        Euler's constant and the base of natural logarithms
      </dd>
      <dd id="defn-*ln10*">
        Natural logarithm of 10
      <dd id="defn-*log10e*">
        Base-10 logarithm of Euler's constant
      </dd>
      <dd id="defn-*log2e*">
        Base-2 logarithm of Euler's constant
      </dd>
      <dd id="defn-*pi*">
        Ratio of the a circle's circumference to its diameter (&pi;)
      <dd id="defn-*sqrt1_2*">
        Square root of 1/2
      </dd>
      <dd id="defn-*sqrt2*">
        Square root of 2
      </dd>
      <dd id="defn-*ln2*">
        Natural logarithm of 2
      <dd id="defn-abs">
        (abs x)
        <p> Absolute value of <i>x</i>; <i>x</i> can be a number or a bigint.
      </dd>
      <dd id="defn-acos">
        (acos x)
        <p> Arccosine of x in radians.
      </dd>
      <dd id="defn-acosh">
        (acosh x)
        <p> Hyperbolic arccosine of x in radians.
      </dd>
      <dd id="defn-asin">
        (asin x)
        <p> Arcsine of x in radians.
      </dd>
      <dd id="defn-asinh">
        (asinh x)
        <p> Hyperbolic arcsine of x in radians.
      </dd>
      <dd id="defn-atan">
        (atan x)
        <p> Arctangent of x in radians.
      </dd>
      <dd id="defn-atanh">
        (atanh x)
        <p> Hyperbolic arctangent of x in radians.
      </dd>
      <dd id="defn-atan2">
        (atan2 y x)
        <p> Angle in radians from the positive x axis and the ray to the point (x, y).
            Does not suffer from divide-by-zero issues as <i>tan</i> would.
      </dd>
      <dd id="defn-sqrt">
        (sqrt x)
        <p> Square root of x.
      </dd>
      <dd id="defn-cbrt"><div>
        (cbrt x)
        <p> Cube root of x.
      </dd>
      <dd id="defn-clz32">
        (clz32 x)
        <p> Number of leading zeros in the binary representation of x
            considered as a 32-bit integer.
      </dd>
      <dd id="defn-cos">
        (cos x)
        <p> Cosine of x in radians.
      </dd>
      <dd id="defn-cosh">
        (cosh x)
        <p> Hyperbolic cosine of x in radians.
      </dd>
      <dd id="defn-expm1">
        (expm1 x)
        <p> The value <code>(- (exp x) 1)</code>, avoiding numerical anomalies.
      </dd>
      <dd id="defn-log1p">
        (log1p x)
        <p> The natural logarithm of <code>x+1</code>, avoiding numerical anomalies.
      </dd>
      <dd id="defn-exp">
        (exp x)
        <p> Euler's number to the power x.
      </dd>
      <dd id="defn-floor">
        (floor x)
        <p> The largest integer less than or equal to x.
      </dd>
      <dd id="defn-ceil">
        (ceil x)
        <p>The smallest integer greater than or equal to x.
      </dd>
      <dd id="defn-fround">
        (fround x)
        <p> The closest single precision floating point representation of x.
      </dd>
      <dd id="defn-hypot">
        (hypot value ...)
        <p> The square root of the sum of the squares of the arguments.
      </dd>
      <dd id="defn-imul">
        (imul x y)
        <p> Result of the multiplication of x and y considered as 32-bit integers.
      </dd>
      <dd id="defn-log">
        (log x)
        <p> The natural logarithm of x.
      </dd>
      <dd id="defn-log10">
        (log x)
        <p> The base-10 logarithm of x.
      </dd>
      <dd id="defn-add">
        (+ value value ...)
        <p> Adds the values.
      </dd>
      <dd id="defn-sub">
        (- value ...)
        <p> Subtracts a series of values from the first value.
            If there is only one argument, negates the value.
      </dd>
      <dd id="defn-mul">
        (* value value ...)
        <p> Multiplies a series of values.
      </dd>
      <dd id="defn-div">
        (/ value ...)
        <p> Divides a series of values from the first value.
            If there is only one argument, returns the reciprocal.
      </dd>
      <dd id="defn-rem">
        (% value value)
        <p> Remainder of the first value divided by the second.
      </dd>
      <dd id="defn-pow">
        (** value value)
        <p> Exponentiates the first value by the second.
      </dd>
      <dd id="defn-and">
        (&& value value ...)
        <p> Evaluates its arguments until one of them is false.
            Results in the first "false" value; otherwise the last value.
            Evaluation ends when a false value is found.
            "False" values are
            <code>false</code>, <code>nil</code>, <code>undefined</code> and
            <code>null</code>; unlike JavaScript,
            zero, NaN and "" are <i>not</i> false.
      </dd>
      <dd id="defn-or">
        (|| value value ...)
        <p> Evaluates its arguments until one of them is true.
          Results in the first "true" value; otherwise the last value.
          Evaluation ends when a true value is found.
          "False" values are
          <code>false</code>, <code>nil</code>, <code>undefined</code> and
          <code>null</code>; unlike JavaScript,
          zero, NaN and "" are <i>not</i> considered false.
          Everything else is "true."
      </dd>
      <dd id="defn-bit-and">
        (& value value ...)
        <p> Bitwise "and" of the values considered as 32-bit integers.
      </dd>
      <dd id="defn-bit-or">
        (| value value ...)
        <p> Bitwise "or" of the values considered as 32-bit integers.
      </dd>
      <dd id="defn-bit-xor">
        (^ value value ...)
        <p> Bitwise exclusive "or" of the values considered as 32-bit integers.
      </dd>
      <dd id="defn-bit-not">
        (~ value)
        <p> Bitwise not of the value considered as a 32-bit integer.
      </dd>
      <dd id="defn-bit-shl">
        (&lt;&lt; value shift)
        <p> <i>Value</i> left-shifted "shift" bits, bith considered as 32-bit integers.
      </dd>
      <dd id="defn-bit-shr">
        (&gt;&gt; value shift)
        <p> <i>Value</i> arithmetcally right-shifted "shift" bits, bith considered as 32-bit integers.
            The sign bit fills from the left.
      </dd>
      <dd id="defn-bit-ushr">
        (&gt;&gt;&gt; value shift)
        <p> <i>Value</i> logically right-shifted "shift" bits, bith considered as 32-bit integers.
          Zero bits fill from the left.
      </dd>
      <dd id="defn-ash">
        (ash value shift)
        <p> Shifts left if <i>shift</i> is positive.
            Shifts arithmetcally right if <i>shift</i> is negative;
            sign bits fill from the left.
      </dd>
      <dd id="defn-append">
        (append list ...)
        <p> Appends the specified lists or iterable JavaScript objects, forming a new list.
      </dd>
      <dd id="defn-apply">
        (apply function args [scope])
        <p> Applies the function to the arguments in the given scope.
            "scope" is optional; the default is the current scope.
      </dd>
      <dd id="defn-begin">
        (begin form ...)
        <p> Evaluates the forms sequentially, returning the value of the last form.
      </dd>
      <dd id="defn-bigint?">
        (bigint? obj)
        <p> Returns <code>true</code> if <i>obj</i> is a JavaScript BigInt.
      </dd>
      <dd id="defn-boolean?">
        (boolean? obj)
        <p> Returns <code>true</code> if <i>obj</i> is a boolean.
      </dd>
      <dd id="defn-function?">
        (boolean? obj)
        <p> Returns <code>true</code> if <i>obj</i> is a JavaScript function.
      </dd>
      <dd id="defn-butlast">
        (butlast list)
        <p> A copy of <i>list</i> excepting the last element.
      </dd>
      <dd id="defn-caaar">
        (caaar list)
        <p> Shorthand for: <code>(car (car (car list)))</code>.
      </dd>
      <dd id="defn-caadr">
        (caadr list)
        <p> Shorthand for: <code>(car (car (cdr list)))</code>.
      </dd>
      <dd id="defn-caar">
        (caar list)
        <p> Shorthand for: <code>(car (car list))</code>.
      </dd>
      <dd id="defn-cadar">
        (cadar list)
        <p> Shorthand for: <code>(car (cdr (car list)))</code>.
      </dd>
      <dd id="defn-caddr">
        (caddr list)
        <p> Shorthand for: <code>(car (cdr (cdr list)))</code>.
      </dd>
      <dd id="defn-cadr">
        (cadr list)
        <p> Shorthand for: <code>(car (cdr list))</code>.
      </dd>
      <dd id="defn-cons">
        (cons first rest)
        <p> Returns a new list object with <i>first</i> as the "car" and <i>rest</i> as the "cdr."
      </dd>
      <dd id="defn-car">
        (car list)
        <p> First element of <i>list</i>.
      </dd>
      <dd id="defn-cdr">
        (cdr list)
        <p> Second and subsequent elements of <i>list</i>.
      </dd>
      <dd id="defn-cdaar">
        (cdaar list)
        <p> Shorthand for: <code>(cdr (car (car list)))</code>.
      </dd>
      <dd id="defn-cdadr">
        (cdadr list)
        <p> Shorthand for: <code>(cdr (car (cdr list)))</code>.
      </dd>
      <dd id="defn-cdar">
        (cdar list)
        <p> Shorthand for: <code>(cdr (car list))</code>.
      </dd>
      <dd id="defn-cddar">
        (cddar list)
        <p> Shorthand for: <code>(cdr (cdr (car list)))</code>.
      </dd>
      <dd id="defn-cdddr">
        (cdddr list)
        <p> Shorthand for: <code>(cdr (cdr (cdr list)))</code>.
      </dd>
      <dd id="defn-cddr">
        (cddr list)
        <p> Shorthand for: <code>(cdr (cdr list))</code>.
      </dd>
      <dd id="defn-closure?">
        (closure? obj)
        <p> True if <i>obj</i> is a Scheme closure.
      </dd>
      <dd id="defn-SchemeCompileError"
        <p> Thrown when the compiler finds an error.
      </dd>
      <dd id="defn-SchemeEvalError">
        <p> Thrown when the there is an error evaluating a Scheme form.
      </dd>
      <dd id="defn-cond">
        (cond cond-clause ...)
        <p> where <i>cond-clause</i> is:</p>
        (predicate form ...)
        <p> Evaluates each predicate sequentially until one is true then
            evaluates the forms in that clause, returning the value
            of the last form.
        <p class="example">
          (cond <br>
          &nbsp;&nbsp; ((< 6 4) "a") <br>
          &nbsp;&nbsp; ((< 4 4) "b") <br>
          &nbsp;&nbsp; ((< 3 4) "c") <br>
          &nbsp;&nbsp; ((< 2 4) "d"))
      </dd>
      <dd id="defn-copy-list">
        (copy-list list)
        <p> Returns a new list that is an element-wise shallow copy of <i>list</i>,
            which can be a Scheme list or JavaScript iterable.
      </dd>
      <dd id="defn-apropos">
        (apropos ["substring"])
        <p> A list of globally-defined functions and values.
            If an optional "substring" parameter is given, it returns only definitions
            whose name contains that substring.
      </dd>
      <dd id="defn-aref">
        (@ index array)
        <p> Indexes into the JavaScript array by the given index. </p>
        (@ "prop" obj)
        <p> The value of the property "prop" in the given object.
      </dd>
      <dd id="defn-aref?">
        (@? index array)
        <p> The value of the property "prop" in the given object or undefined if the array is
            undefined or null.</p>
        (@ "prop" obj)
        <p> The value of the property "prop" in the given object or undefined if the array is
            undefined or null.
      </dd>
      <dd id="defn-array?">
        (array? obj)
        <p> True if the object is a JavaScript Array.
      </dd>
      <dd id="defn-false">
        false
        <p> The canonical "false" value.
            Only <code>false</code>, <code>nil</code>, <code>undefined</code> and
            <code>null</code> are considered false; unlike JavaScript,
            zero, NaN and "" are <i>not</i> considered false.
            Everything else is "true."
      </dd>
      <dd id="defn-true">
        true
        <p> The canonical "true" value.
            Only <code>false</code>, <code>nil</code>, <code>undefined</code> and
            <code>null</code> are considered false; unlike JavaScript,
            zero, NaN and "" are considered true.
            Everything else is "true."
      </dd>
      <dd id="defn-intern">
        (intern "str")
        <p> Returns a Scheme atom named "str".
      </dd>
      <dd id="defn-define">
        (define a form)
        <p> Defines a global-scope variable <i>a</i> with the evaluated value of <i>form</i>.</p>
        (define (fn param...) form ...)
        <p> Defines a global-scope function <i>fn</i> with parameters <i>param...</i>
            which evaluates the forms in the context of the bound parameters.
      </dd>
      <dd id="defn-compile">
        (compile (fn param...) form ...)
        <p> Compiles and defines a global-scope function <i>fn</i> with parameters <i>param...</i>
            which evaluates the forms in the context of the bound parameters.
      </dd>
      <dd id="defn-delete">
        (delete a b)
        <p> Deletes property or array element <i>b</i> from JavaScript object <i>a</i>.
      </dd>
      <dd id="defn-eval">
        (eval form [scope])
        <p> Evaluates <i>form</i> in the given <i>scope</i>.
            Default is the scope of the caller.
      </dd>
      <dd id="defn-eval-string">
        (eval-string "str" [scope])
        <p> Parses and evaluates <i>"str"</i> in the given (optional) <i>scope</i>.
            Default scope is the caller's.
      </dd>
      <dd id="defn-@">
        (@ obj n)
        <p> References element <i>n</i> of JavaScript array <i>obj</i>.</p>
        (@ obj "name")
          <p> References member <i>n<name/i> of JavaScript object <i>obj</i>.
      </dd>
      <dd id="defn-@?">
        (@? obj n)
        <p> References element <i>n</i> of JavaScript array <i>obj</i> if <i>obj</i> is not null
            or undefined, otherwise returns undefined.</p>
        (@"" obj "name")
        <p> References member <i>n<name/i> of JavaScript object <i>obj</i> if <i>obj</i> is not null
            or undefined, otherwise returns undefined.
      </dd>
      <dd id="defn-@!">
        (@! obj "member" ... params)
        <p> Invokes member function <i>member</i> in JavaScript object <i>obj</i>. E.g.</p>
        (@! Math "sin" (/ *pi* 4))
      </dd>
      <dd id="defn-@=">
        (@= obj "member" value)
        <p> Assigns <i>value</i> to JavaScript member <i>member</i> in object <i>obj</i>.
      </dd>
      <dd id="defn-lambda">
        (\ (p1 p2 ...) form ...)
        <p> Returns a closure that binds parameters <i>p1</i>, <i>p2</i>, etc. to the arguments,
            then evaluates the <i>form</i>s sequentially, returning the value of the last one or
            <i>nil</i> if there are none
      </dd>
      <dd id="defn-lambda#">
        (\# n (p1 p2 ...) form ...)
        <p> Returns a closure that binds parameters <i>p1</i>, <i>p2</i>, etc. to the arguments,
            then evaluates the first <code>n</code> <i>form</i>s sequentially, returning the value of the last one or
            <i>nil</i> if there are none. ("Special" evaluation in the lingo, I think.)
      </dd>
      <dd id="defn-not">
        (! value)
        <p> Logical "not." Returns <i>true</i> if <i>value</i> is not true.
            "False" values are
            <code>false</code>, <code>nil</code>, <code>undefined</code> and
            <code>null</code>; unlike JavaScript,
            zero, NaN and "" are <i>not</i> considerd false.
            Everything else is "true."
      </dd>
      <dd id="defn-eqv">
        (== a b ...)
        <p> Returns true if all the values are equal to each other.
            Evaluation ends when two items are different.
      </dd>
      <dd id="defn-ne">
        (!= a b ...)
        <p> Returns true unless all the values are equal to each other.
            Evaluation ends when two items are different.
      </dd>
      <dd id="defn-lt">
        (< a b ...)
        <p> Returns true if each value is less than the previous.
            Evaluation ends as soon as this is not the case.
      </dd>
      <dd id="defn-le">
        (<= a b ...)
        <p> Returns true if each value is less than or equal to the previous.
            Evaluation ends as soon as this is not the case.
      </dd>
      <dd id="defn-gt">
        (> a b ...)
        <p> Returns true if each value is greater than the previous.
            Evaluation ends as soon as this is not the case.
      </dd>
      <dd id="defn-ge">
        (> a b ...)
        <p> Returns true if each value is greater than or equal the previous.
            Evaluation ends as soon as this is not the case.
      </dd>
      <dd id="defn-quote">
        'a
        <br>
        (quote a)
        <p> Prevents <code>a</code> from being evaluated and returns it literally.
      </dd>
      <dd id="defn-!==">
        (!== a b ...)
        <p> Reuurns false unless all values are === in the JavaScript sense.
            Evaluation ends as soon as any items are unequal.
      </dd>
      <dd id="defn-===">
        (=== a b ...)
        <p> Returns true if all values are === in the JavaScript sense.
            Evaluation ends as soon as any items are unequal.
      </dd>
      </dd>
      <dd id="defn-if">
        (? predicate true-expr false-expr)
        <p> If the predicate is true,
            (any value other than <code>false</code>, <code>undefined</code>, <code>null</code> or <code>nil</code>),
            evaluates and returns <code>true-expr</code>; otherwise evaluates and returns <code>false-expr</code>.
        <p> "?" can be partially-evaluated. <code>(? true)</code> results in a closure that evaluates
            and returns its first argument; <code>(? false)</code> results in a closude that evaluates and
            returns its second argument.
      </dd>
      <dd id="defn-nullish">
        (?? form ...)
        <p> Evaluates the series of forms, returning the first which is neither null or undefined.
            Evaluation ends as soon as a value is returned.
      </dd>
      <dd id="defn-defn-@?!"></dd>
      <dd id="defn-@@"></dd>
      <dd id="defn-@?!"></dd>
      <dd id="defn-@@!"></dd>
      <dd id="defn-@@="></dd>
      <dd id="defn-@@?"></dd>
      <dd id="defn-@@?!"></dd>
      <dd id="defn-@@@"></dd>
      <dd id="defn-@@@!"></dd>
      <dd id="defn-@@@="></dd>
      <dd id="defn-@@@?"></dd>
      <dd id="defn-@@@?!"></dd>
      <dd id="defn-in"></dd>
      <dd id="defn-Array"> Array <p> The JavaScript Array class. </dd>
      <dd id="defn-Boolean"> Boolean <p> The JavaScript Boolean class. </dd>
      <dd id="defn-Number"> Number <p> The JavaScript Number class. </dd>
      <dd id="defn-BigInt"> BigInt <p> The JavaScript BigInt class. </dd>
      <dd id="defn-String"> String <p> The JavaScript String class. </dd>
      <dd id="defn-Object"> Object <p> The JavaScript Object class. </dd>
      <dd id="defn-Symbol"> Symbol <p> The JavaScript Symbol class. </dd>
      <dd id="defn-map">
        (map fn list...)
        <p> Returns a list of results of <code>fn</code> applied to each element
            of the given lists (or JavaScript iterables such as JavaScript Arrays).
      </dd>
      <dd id="defn-lazy-map">
        (lazy-map fn list...)
        <p> Returns a list of results of <code>fn</code> applied to each element
            of the given lists (or JavaScript iterables such as JavaScript Arrays).
            The twist is it doesn't evaluate the function until someone accesses the "car"
            of the resulting virtual list or iterate to the next element until someone accesses
            "cdr."
      </dd>
      <dd id="defn-array-map">
        (array-map fn list...)
        <p> Returns a JavaScript Array of results of <code>fn</code> applied to each element
            of the given lists (or JavaScript iterables such as Arrays).
      </dd>
      <dd id="defn-filter">
        (filter predicate-fn list...)
        <p> Returns a list of elemenys of the given lists
            (or JavaScript iterables) where the <code>predicate-fn</code> applied to the
            element is true.
      </dd>
      <dd id="defn-atom?">
        (atom? a)
        <p> True if <code>a</code> is an atom.
      </dd>
      <dd id="defn-finite?">
        (finite? a)
        <p> True if <code>a</code> is neither infinite or a NaN.
      </dd>
      <dd id="defn-nan?">
        (list? a)
        <p> True if <code>a</code> is a NaN value.
      </dd>
      <dd id="defn-list?">
        (list? a)
        <p> True if <code>a</code> is either a cons cell (pair) or nil.
      </dd>
      <dd id="defn-nullish?">
        (list? a)
        <p> True if <code>a</code> is either a undefined or null.
      </dd>
      <dd id="defn-number?">
        (list? a)
        <p> True if <code>a</code> is a Number.
      </dd>
      <dd id="defn-numeric?">
        (list? a)
        <p> True if <code>a</code> is either a Number or a BigInt.
      </dd>
      <dd id="defn-object?">
        (list? a)
        <p> True if <code>a</code> is a JavaScript Object (exclusive of Functions and null).
      </dd>
      <dd id="defn-xxx">
        (list? a)
        <p> True if <code>a</code> is either a cons cell (pair) or nil.
      </dd>
      <dd id="defn-pair?">
        (list? a)
        <p> True if <code>a</code> is either a cons cell (pair).
      </dd>
      <dd id="defn-string?">
        (list? a)
        <p> True if <code>a</code> is a String.
      </dd>
      <dd id="defn-symbol?">
        (list? a)
        <p> True if <code>a</code> is a JavaScript Symbol (including atoms).
      </dd>
      <dd id="defn-undefined?">
        (list? a)
        <p> True if <code>a</code> is JavaScript "undefined". Undefined does not
            turn up much in SchemeJS, but is the result of the <code>void</code> function
            and the value of the "undefined" keyword.
      </dd>
      <dd id="defn-null?">
        (list? a)
        <p> True if <code>a</code> is nil.
            The name is unfortunate, but SIOD already uses "null?" to test for nil.
      </dd>
      <dd id="defn-jsnull?">
        (list? a)
        <p> True if <code>a</code> is JavaScript "null".
            The name is unfortunate, but SIOD already uses "null?" to test for nil.
      </dd>
      <dd id="defn-gensym">
        (gensym [name]))
        <p> Generates a unique Symbol that is not equal to any other object and is not an atom.
            If a string-valued <code>name</code> is provided, that will be the Symbol's "description."
      </dd>
      <dd id="defn-globalThis">
        globalThis
        <p> The JavaScript global scope.
      </dd>
      <dd id="defn-globalScope">
        globalScope
        <p> The SchemeJS global scope.
      </dd>
      <dd id="defn-sort">
        (sort list [beforeFn] [accessFn])
        <p> Sorts <code>list</code> such if <code>beforeFn</code> is applied to elements
            <code>a</code> and <code>b</code>, then <code>a</code> will be before <code>b</code>
            in the sorted list; the default is <code>&lt;</code>.
            The <code>accessFn</code> selects the "key" to be sorted; the default
            is the element itself.
        <p> The "list" can be any iterable JavaScript object, but if it is an Array, the result
            will also be an Array.
        <p> The <code>qsort</code> alias is for SIOD compatibility; it is not the qsort algorithm
            though the performance is comparable and often better.
      </dd>
      <dd id="defn-nsort">
        (sort list [beforeFn] [accessFn])
        <p> In-place sort: like <code>sort</code>, but modifies the given list or Array.
      </dd>
      <dd id="defn-last">
        (last obj)
        <p> Returns the last element of the list or JavaScript iterable object.
            Strings and Arrays are iterable, so this will return the last
            character of a string or Array.
      </dd>
      <dd id="defn-length">
        (length obj)
        <p> Returns the length of a list or JavaScript iterable object such as a string or Array.
      </dd>
      <dd id="defn-list">
        (list element ...)
        <p> Returns a list of the arguments.
      </dd>
      <dd id="defn-list-view">
        (list-view js-iterable)
        <p> Returns an object indistiguishible to SchemeJS from a list that iterates the elements
            of an iterable JavaScript-style on demand. In other words, a lazy version of <code>to-list</code>
      </dd>
      <dd id="defn-to-list">
        (to-list js-iterable)
        <p> Returns a list of the elements of an iterable JavaScript object. See also, <code>list-view</code>.
      </dd>
      <dd id="defn-max">
        (max a b ...)
        <p> Returns the largest element among its arguments.
      </dd>
      <dd id="defn-min">
        (min a b ...)
        <p> Returns the smallest element among its arguments.
      </dd>
      <dd id="defn-reverse">
        (reverse list)
        <p> Returns a new list that is a reversed version of the list or JavaScript iterable argument.
      </dd>
      <dd id="defn-nreverse">
        (nreverse list)
        <p> In-place reverses and returns the list. To be clear, this function modifies its argument.
      </dd>
      <dd id="defn-to-array">
        (to-array obj [depth])
        <p> Traverses the list or other iterable, converting it to an array, recursively to the
          given depth (default 1).
      </dd>
      <dd id="defn-to-list">
        (to-list obj [depth])
        <p> Traverses the list or other iterable, converting it to an list, recursively to the
          given depth (default 1).
      </dd>
      <dd id="defn-nth">
        (nth list)
        <p> Returns the "nth" element of the list or other JavaScript iterable.
      </dd>
      <dd id="defn-xxx">
        xxx
        <p> xxx
      </dd>
    </div>
    <script type="module" src="./CloseButton.mjs"></script>
    <script type="text/javascript">
      "use strict";

      const bodyElement = document.getElementById('body');
      const containerElement = document.getElementById('container');
      const inputElement = document.getElementById('input');
      const outputElement = document.getElementById('output');
      const loadFileInputElement = document.getElementById('load-file-dialog');
      let globalScope, SCHEME_VERSION;
      let SchemeParseError, SchemeSyntaxError, SchemeParseIncompleteError, SchemeEvalError;
      let NIL, Atom, string, defineGlobalSymbol, originalLoad;
      let varNo = 0, WS, NL;
      const NBSP = '\u00a0', lambdaStr = "\u03BB";
      const optional = undefined;  // so that parameters show up pretty when printed
      let traceCompilerCode = true;

      onload = importSchemeAndRunREPL();
      async function importSchemeAndRunREPL() {
        let SchemeJS = await(import("./SchemeJS.mjs"));
        globalScope = SchemeJS.createInstance({
          lambdaStr, readFile, linePrinter, traceCompilerCode,
          reportLoadResult, reportLoadInput, reportSchemeError, reportSystemError
        });
        SCHEME_VERSION = globalScope.VERSION;
        SchemeParseError = globalScope.SchemeParseError;
        SchemeSyntaxError = globalScope.SchemeSyntaxError;
        SchemeParseIncompleteError = globalScope.SchemeParseIncompleteError;
        SchemeEvalError = globalScope.SchemeEvalError;
        NIL = globalScope.NIL;
        string = globalScope.string;
        Atom = globalScope.Atom;
        defineGlobalSymbol = globalScope.defineGlobalSymbol;
        defineGraphicsFunctions();
        let loadAtom = Atom("load")
        originalLoad = globalScope[loadAtom];
        globalScope[loadAtom] = load;
        WS = globalScope.WS;
        NL = globalScope.NL;
        buildBuiltinHelp(globalScope);

        // The idea here is to let the handleInput exacute after the keypress has been
        // completely processed. "oninput" is nice, but doesn't indicate the "Enter" key.
        inputElement.onkeydown = event => setTimeout(() => handleInput(event.key === 'Enter'), 0);

        // TODO: I'm just looking for selection changes; there's probably a better way
        inputElement.onmousedown = event => setTimeout(() => handleInput(), 0);
        
        inputElement.contentEditable = 'true';
        inputElement.focus();
      }

      // For "load" and "require"
      let capturedInput, loadPath, loadLine, loadLineCount, loadAsyncContent;

      function load(path = optional, noEval = false) {
        if (path)
          doXHRLoad();
        else
          doFileLoad();
        return NIL;
        async function doXHRLoad() {
          let xhr = new Promise((resolve, reject) => {
            let request = new XMLHttpRequest();
            // Bypass the cache.
            //   https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#bypassing_the_cache
            let reqPath = path + ((/\?/).test(path) ? "&" : "?") + (new Date()).getTime()
            request.onload = _ => {
              if (request.status === 200)
                resolve(request.responseText);
              else
                reject(new Error(`Load ${path}, status ${request.status}`));
            };
            request.onerror = _ => {
              // Try again without the query param (this is for PWAs that may have cached the resource for offline)
              request = new XMLHttpRequest();
              request.onload = _ => {
                if (request.status === 200)
                  resolve(request.responseText);
                else
                  reject(new Error(`Load ${path}, status ${request.status}`));
              }
              request.onerror = event => reject(new Error(`XMLHttpRequest error ${String(event)}`));
              let async = true;
              request.open('GET', reqPath, async);
              request.send(null);
            }
            let async = true;
            request.open('GET', reqPath, async);
            request.send(null);
          });
          try {
            let content = await xhr;
            invokeLoadWithPathAndContent(path, content);
          } catch (error) {
            showError(error);
          }
        }
        function doFileLoad() {
            loadFileInputElement.onchange =  function handleFileLoad(event) {
              let fileList = this.files, file = fileList[0];
              loadContent(file);
              async function loadContent(file) {
                let path = file.name;
                let content = await(file.text());
                invokeLoadWithPathAndContent(path, content);
              }
            };
            loadFileInputElement.click();
        }
        function invokeLoadWithPathAndContent(path, content) {
          let saveLoadAsyncContent = loadAsyncContent, savePath = loadPath, saveLine = loadLine, saveLoadLineCount = loadLineCount;
          loadAsyncContent = content;
          loadPath = path;
          loadLine = 0;
          loadLineCount = 0;
          let res;
          try {
            res = originalLoad.call(globalScope, path, noEval);
          } finally {
            loadAsyncContent = saveLoadAsyncContent;
            loadPath = savePath;
            loadLine = saveLine;
            loadLineCount = saveLoadLineCount;
          }
          return res;
        }
      }

      function readFile(path) {
        let content = loadAsyncContent;
        if (content === undefined) {
          let request = new XMLHttpRequest();
          let reqPath = path + ((/\?/).test(path) ? "&" : "?") + (new Date()).getTime()
          request.onerror = event => reject(new Error(`XMLHttpRequest error ${String(event)}`));
          let async = false;
          request.open('GET', reqPath, async);
          request.send(null);
          if (request.status !== 200)
            throw new Error(`Load ${path}, status ${request.status}`);
          content = request.responseText;
        }
        capturedInput = '';
        return captureInput(loadAsyncContent);
        return null;
        function* captureInput(source) {
          for (let ch of source) {
            // Eat up initial whitespace and newlines so the reported line
            // isn't at the head of whitespace
            if (capturedInput === '') {
              if (ch === '\n') {
                loadLineCount += 1;
                continue;
              }
              if (WS[ch])
                continue;
              loadLine = loadLineCount+1;
            }
            capturedInput += ch;
            if (NL[ch])
              loadLineCount += 1;
            yield ch;
          }
        }
      }

      function reportLoadInput(expr) {
        varNo += 1;
        showInput(capturedInput, loadPath, loadLine, expr, varNo);
        capturedInput = '';
      }

      function reportLoadResult(result, expr) {
        showResult(result, varNo);
      }

      function reportSchemeError(error, expr) {
        showInput(capturedInput, loadPath, loadLine);
        capturedInput = '';
        showError(error);
      }

      function reportSystemError(error, expr) {
        showInput(capturedInput, loadPath, loadLine);
        capturedInput = '';
        showError(error);
      }

      let helpStack = [];

      function showHelp(id) {
        let elts = document.querySelectorAll('div.help');
        for (let e of elts)
          e.style.display = ''; // back to inherited 'none'
        if (!id) {
          helpStack.pop();
          if (helpStack.length > 0)
            helpStack[helpStack.length-1].style.display = 'block';
          return;
        }
        id = id.split("#");
        let frag = id[1];
        id = id[0];
        let helpElement = document.getElementById(id);
        if (helpElement) {
          helpStack.push(helpElement);
          helpElement.style.display = 'block'; // inherits 'none' from "help" class
          let contentElement = helpElement.querySelector('div');
          if (contentElement) {
            contentElement.scrollTop = 0;
            if (frag) {
              let element = contentElement.querySelector(`#${frag}`);
              if (element)
                element.scrollIntoView(true);
            }
          }
        }
      }

      function buildBuiltinHelp(globalScope) {
        const string = globalScope.string;
        let helpGroups = globalScope._helpgroups_, groups = {};
        // Invert by group on atom value
        for (let atom of Object.getOwnPropertySymbols(helpGroups)) {
          let value = globalScope[atom], helpGroup = helpGroups[atom];
          if (value === undefined) continue;
          let groupMap = groups[helpGroup];
          if (!groupMap)
            groupMap = groups[helpGroup] = new Map();
          let valueObj = groupMap.get(value);
          if (!valueObj)
            groupMap.set(value, valueObj = { atoms: [], jsNames: [] });
          valueObj.atoms.push(atom);
        }
        // Add JavaScript names
        for (let jsName of Object.getOwnPropertyNames(helpGroups)) {
          let value = globalScope[jsName], helpGroup = helpGroups[jsName];
          if (value === undefined) continue;
          let groupMap = groups[helpGroup];
          if (!groupMap) continue;
          let valueObj = groupMap.get(value);
          if (!valueObj) continue
          valueObj.jsNames.push(jsName);
        }
        // Organize into a symbol table by group then sort on a transformation of the first
        // atom defined. "groups" is now: groups[groupName] = (sorted)[{ key, atoms: [], jsNames: [] }];
        for (let helpGroup in groups) {
          let groupMap = groups[helpGroup];
          let symtab = [];
          for (let [map_key_which_is_the_value, valueObj] of groupMap.entries()) {
            valueObj.key = keyFor(valueObj.atoms[0]);
            valueObj.value = map_key_which_is_the_value;
            symtab.push(valueObj);
          }
          symtab.sort((a, b) => a.key < b.key ? -1 : 1);
          groups[helpGroup] = symtab;
        }
        for (let helpGroup in groups) {
          let symtab = groups[helpGroup];
          let helpElement = document.getElementById(`helpgroup-${helpGroup}`);
          if (!helpElement) {
            console.error("Missing help group", helpGroup);
            continue;
          }
          for (let { atoms, jsNames, value } of symtab) {
            for (let atom of atoms)
            if (helpGroup === "imported") {
              let atomDesc = atom.description, anchor = createElement('a', null, atomDesc);
              let href = `https://developer.mozilla.org/docs/Web/API/${atomDesc}`;
              if (atomDesc.includes('-')) {  // reassigned names, like Object-getOwnPropertyNames
                let parts = atomDesc.split('-');
                href = `https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/${parts[0]}/${parts[1]}`;
              }
              anchor.setAttribute('href', href);
              let dt = createElement('dt');
              dt.appendChild(anchor);
              helpElement.appendChild(dt);
            } else {
              helpElement.appendChild(createElement('dt', null, atom.description));
            }
            let dd;
            for (let atom of atoms) {
              let elementId = "defn-" + atom.description;
              dd = document.getElementById(elementId);
              if (dd) break;
            }
            if (!dd) {
              dd = createElement('dd');
              dd.appendChild(createElement('span', 'tbd', `TBD defn-${atoms[0].description}`));
            }
            helpElement.appendChild(dd);
            if (typeof value === 'function')
              dd.appendChild(createElement('p', 'impl', string(value)));
            else
              dd.appendChild(createElement('p', 'value', string(value)));
            if (jsNames.length > 0) {
              let jsNamesElement = createElement('p', 'js-names');
              dd.appendChild(jsNamesElement);
              for (let jsName of jsNames)
                jsNamesElement.appendChild(createElement('span', 'js-name', jsName));
            }
          }
        }

        function keyFor(atom) {
          let key = atom.description, alpha = "abcdefghijklmnopqrstuvwxyz", stripPrefixSyms = "*#!?";
          key = key.toLowerCase();
          // Strip certain special symbols before alpha (mostly for *catch and *throw)
          if (stripPrefixSyms.includes(key[0]) && alpha.includes(key[1]))
            key = key.substr(1);
          // Anything that doesn't begin with an alpha gets sorted to the top (space sorts lowest)
          if (!alpha.includes(key[0]))
            key = ' ' + key;
          return key;
        }
      }

      function createElement(type = 'div', cls, text) {
        let element = document.createElement(type);
        if (cls)
          element.setAttribute('class', cls);
        if (text)
          element.textContent = text;
        return element;
      }

      const LOCAL_STORAGE_KEY = `SchemeJS-${location.pathname}`;
      const appVersion = "1.1";
      let persistedState = {};

      function saveState() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        persistedState.version = appVersion;
        let json = JSON.stringify(wad);
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, json);
          return true;
        }
        catch (_) {
        }
        return false;
      }

      function loadState() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        let json = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!json)
          return false;
        let wad;
        try {
          wad = JSON.parse(json);
        } catch (_) {
          //  ¯\_(ツ)_/¯
        }
        if (typeof wad !== 'object')
          return false;
        let appVer = appVersion.split('.'), saveVer = wad.version.split('.');
        if (!(Number(saveVer[0]) <= Number(appVer[0])))  // handles undefined implicitly
          return false;
        persistedState = wad;
        return true;
      }

      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape')
          showHelp(null);
      });

      let gfxContextAtom, drawAtom, animateAtom, clearCanvasAtom, backingBufferAtom;
      let showAtom, hideAtom, clearColorAtom;
      let xAtom, yAtom, widthAtom, heightAtom;
      let contextToSchemeWidget = new WeakMap();

      class SchemeWidget {
        get x() { return this[xAtom] }
        set x(value) { this[xAtom] = value }
        get y() { return this[yAtom] }
        set y(value) { this[yAtom] = value }
        get width() { return this[widthAtom] }
        set width(value) { this[widthAtom] = value }
        get height() { return this[heightAtom] }
        set height(value) { this[heightAtom] = value }
        get drawFn() { this[drawAtom] }
        set drawFn(value) { this[drawAtom] = value }
        get animate() { this[animateAtom] }
        set animate(value) { this[animateAtom] = value }
        get animate() { this[animateAtom] }
        set animate(value) { this[animateAtom] = value }
        get clearCanvas() { this[clearCanvasAtom] }
        set clearCanvas(value) { this[clearCanvasAtom] = value }
        get clearColor() { this[clearColorAtom] }
        set clearColor(value) { this[clearColorAtom] = value }
        backingBuffer(width, height) { return this[backingBufferAtom](width, height) }
        show(...params) { return this[showAtom](...params) }
        hide() { this[hideAtom]() }
      }

      function defineGraphicsFunctions() {
        let newCanvasX = 20, newCanvasY = 10;
        gfxContextAtom = Atom("gfx-context"), drawAtom = Atom("draw");
        animateAtom = Atom("animate"), clearCanvasAtom = Atom("clear-canvas"), backingBufferAtom = Atom("backing-buffer");
        showAtom = Atom("show"), hideAtom = Atom("hide"), clearColorAtom = Atom("clear-color");
        xAtom = Atom("x"), yAtom = Atom("y"), widthAtom = Atom("width"), heightAtom = Atom("height");

        defineGlobalSymbol("canvas", canvas, { dontInline: true, group: "web-gfx" });
        function canvas(name = "canvas", width = 200, height = width) { 
          let canvasFrame = createElement('div', 'canvas-frame');
          let canvasTitleBar = createElement('div', 'title-bar');
          let titleSpan = createElement('span', 'title', name);
          let canvasCloseButton = createElement('close-button');
          canvasTitleBar.appendChild(canvasCloseButton);
          canvasTitleBar.appendChild(titleSpan);
          let canvasElement = createElement('canvas', 'drawing-canvas');
          canvasFrame.appendChild(canvasTitleBar);
          canvasFrame.appendChild(canvasElement);
          let drawFn, _staleImage = false, animate = false, animating = false;
          let clearCanvasMode = true, clearColor, forceClear = true;
          let canvas2dRenderingContext = canvasElement.getContext('2d');
          let backingBufferWidth = 0, backingBufferHeight = 0, backingCanvas, backing2dRenderingContext;
          function _resizeWithoutSmashingContent(newWidth, newHeight) {
            let scratch = createElement('canvas'), ctx = scratch.getContext('2d');
            let width = canvasElement.width, height = canvasElement.height;
            // Unfortunately, you can't set them together
            scratch.width = width;
            scratch.height = height;
            ctx.drawImage(canvasElement, 0, 0, width, height, 0, 0, width, height);
            canvasElement.width = newWidth;
            canvasElement.height = newHeight;
            canvas2dRenderingContext.save();
            canvas2dRenderingContext.resetTransform();
            if (clearColor) {
              canvas2dRenderingContext.fillStyle = clearColor;
              canvas2dRenderingContext.fillRect(0, 0, newWidth, newHeight);
            }
            canvas2dRenderingContext.drawImage(scratch, 0, 0, width, height, 0, 0, width, height);
            canvas2dRenderingContext.restore();
          }
          let schemeWidget = { // Can access state through scoped references
            get canvasElement() { return canvasElement },
            get canvasFrame() { return canvasFrame },
            get canvas2dRenderingContext() { return canvas2dRenderingContext },
            get [xAtom]() { return parseInt(canvasFrame.style.left) },
            set [xAtom](x) { canvasFrame.style.left = x+"px" },
            get [yAtom]() { return parseInt(canvasFrame.style.top) },
            set [yAtom](y) { canvasFrame.style.top = y+"px" },
            get [widthAtom]() { return Number(canvasElement.width) },
            set [widthAtom](width) { _resizeWithoutSmashingContent(width, canvasElement.height) },
            get [heightAtom]() { return Number(canvasElement.height) },
            set [heightAtom](height) { _resizeWithoutSmashingContent(canvasElement.width, height) },
            get [drawAtom]() { return drawFn; },
            set [drawAtom](fn) {
              if (typeof fn !== 'function')
                throw new SchemeEvalError(`[draw] not a function ${string(fn)}`);
              drawFn = fn;
              _staleImage = true;
              window.requestAnimationFrame(animate ? startAnimation : _doRedraw);
            },
            get [animateAtom]() { return animate },
            set [animateAtom](value) {
              animate = value;
              if (animate)
                startAnimation();
            },
            get [clearCanvasAtom]() { return clearCanvasMode },
            set [clearCanvasAtom](value) { clearCanvasMode = value },
            get [clearColorAtom]() { return clearColor },
            set [clearColorAtom](value) { clearColor = value; forceClear = true; },
            [backingBufferAtom](width, height = width) {
              backingBufferWidth = width;
              backingBufferHeight = height;
            },
            [showAtom](x = optional, y = optional, width = optional, height = optional) {
              if (x !== undefined) this.x = x;
              if (y !== undefined) this.y = y;
              if (width !== undefined) this.width = width;
              if (height !== undefined) this.height = height;
              containerElement.appendChild(canvasFrame);
              if (animate)
                startAnimation();
              return this;
            },
            [hideAtom]() {
              if (canvasFrame.parentNode)
                canvasFrame.parentNode.removeChild(canvasFrame);
              return this;
            },
          };
          Object.setPrototypeOf(schemeWidget, SchemeWidget.prototype);
          contextToSchemeWidget.set(canvas2dRenderingContext, schemeWidget);
          let drawTime = Date.now();
          let tickCount = 0;
          function _doRedraw() {
            // Encapsulate common drawing and animation patterns in an easy
            // declatative structure
            if (!(drawFn && _staleImage && canvasFrame.parentElement)) return;
            let now = Date.now();
            if (now - drawTime > 200 /* ms */) // Stale stash -- heuristic!
              schemeWidget.stashX = schemeWidget.stashY = undefined;
            drawTime = now;
            let renderingContext = canvas2dRenderingContext;
            let canvasWidth = canvasElement.width, canvasHeight = canvasElement.height;
            // If we're using a backing buffer make sure it (a) exists and (b) is big enough
            if (backingBufferWidth > 0 && backingBufferHeight > 0) {
              let neededWidth = backingBufferWidth > canvasWidth ? backingBufferWidth : canvasWidth;
              let neededHeight = backingBufferHeight > canvasHeight ? backingBufferHeight : canvasHeight;
              let oldBackingCanvas = backingCanvas, oldBacking2dRenderingContext = backing2dRenderingContext;
              if (!oldBackingCanvas || neededWidth !== oldBackingCanvas.width || neededHeight !== oldBackingCanvas.height) {
                backingCanvas = createElement('canvas');
                backingCanvas.width = neededWidth;
                backingCanvas.height = neededHeight;
                backing2dRenderingContext = backingCanvas.getContext('2d');
                contextToSchemeWidget.set(backing2dRenderingContext, schemeWidget);
                // Clear to the clearColor, if any
                if (clearColor) {
                  backing2dRenderingContext.save();
                  backing2dRenderingContext.fillStyle = clearColor;
                  backing2dRenderingContext.fillRect(0, 0, neededWidth, neededHeight);
                  backing2dRenderingContext.restore();
                }
                // Transfer old contents to the new buffer
                if (oldBackingCanvas) {
                  let w = oldBackingCanvas.width, h = oldBackingCanvas.height;
                  if (neededWidth < w) w = neededWidth;
                  if (neededHeight < h) h = neededHeight;
                  backing2dRenderingContext.drawImage(oldBackingCanvas, 0, 0, w, h, 0, 0, w, h);
                  contextToSchemeWidget.delete(oldBacking2dRenderingContext);
                } else {
                  let w = canvasElement.width, h = canvasElement.height;
                  if (neededWidth < w) w = neededWidth;
                  if (neededHeight < h) h = neededHeight;
                  backing2dRenderingContext.drawImage(canvasElement, 0, 0, w, h, 0, 0, w, h);
                }
              }
              renderingContext = backing2dRenderingContext;
            } else {
              backingCanvas = backing2dRenderingContext = undefined;
            }
            renderingContext.resetTransform();
            // The spec says there's supposed to be a reset method, but MDN
            // doesn't mention it and, emperically, it doesn't exist (yet?).
            // https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-reset
            //   canvas2dRenderingContext.reset();
            // So instead, pop a buncha renderingContexts, reset the
            // transform and, optionally clear the screen
            for (let i = 0; i < 20; ++i);
              renderingContext.restore();
            renderingContext.save();  // So we can easily restore context (just above)
            if (clearCanvasMode || forceClear) {
              forceClear = false;
              if (clearColor) {
                renderingContext.save();
                renderingContext.fillStyle = clearColor;
                renderingContext.fillRect(0, 0, canvasWidth, canvasHeight);
                renderingContext.restore();
              } else {
                renderingContext.clearRect(0, 0, canvasWidth, canvasHeight);
              }
            }
            renderingContext.beginPath();  // Make sure no path parts hanging around
            drawFn(renderingContext, tickCount++);
            if (backingCanvas)
              canvas2dRenderingContext.drawImage(backingCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, canvasWidth, canvasHeight);
            _staleImage = false;
          }
          function redraw() {
            _staleImage = true;
            requestAnimationFrame(_doRedraw);
          }
          function startAnimation() {
            // Take special care to not get multiple animation loops going.
            if (animating) return;
            if (!(drawFn && animate && canvasFrame.parentElement)) return;
            animating = true;
            window.requestAnimationFrame(drawAnimation);
            function drawAnimation() {
              _staleImage = true;
              _doRedraw();
              if (drawFn && animate && canvasFrame.parentElement)
                return window.requestAnimationFrame(drawAnimation);
              animating = false;
            }
          }
          canvasCloseButton.addEventListener('click', _ => schemeWidget.hide());
          canvasFrame.addEventListener('mousedown', mouseDown);
          canvasFrame.addEventListener('touchstart', mouseDown);
          function mouseDown(event) {
            let border = 10;
            let { pageX, pageY } = event;
            let initialX = pageX, initialY = pageY;
            let { top, right, left, bottom } = canvasFrame.getBoundingClientRect();
            let canvasWidth = canvasElement.width, canvasHeight = canvasElement.height;
            let i = 0;
            if (pageX < left + border) i = 0;
            else if (pageX > right - border) i = 2;
            else i = 1;
            if (pageY < top + border) i += 0;
            else if (pageY > bottom - border) i += 6
            else i += 3;
            let [fx, fw, fy, fh] = [
              [1, -1, 1, -1], [0, 0, 1, -1], [0, 1, 1, -1],
              [1, -1, 0,  0], [1, 0, 1,  0], [0, 1, 0,  0],
              [1, -1, 0,  1], [0, 0, 0,  1], [0, 1, 0,  1],
            ][i];
            let moveOK = false, threshold = 4;
            function mouseMove(event) {
              ({pageX, pageY} = event);
              let deltaX = pageX - initialX, deltaY = pageY - initialY;
              if (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold) {
                moveOK = true;
                // Place element at the end of its parent's node list so it diplays on top.
                // But only if it hasn't been removed!
                if (canvasFrame.parentNode)
                  canvasFrame.parentNode.appendChild(canvasFrame);
              }
              if (!moveOK) return;
              if (fx !== 0) schemeWidget.x = left + fx * deltaX;
              if (fy !== 0) schemeWidget.y = top + fy * deltaY;
              if (fw !== 0) schemeWidget.width = canvasWidth + fw * deltaX;
              if (fh !== 0) schemeWidget.height = canvasHeight + fh * deltaY;
            }
            function mouseUp(event) {
              bodyElement.removeEventListener('mousemove', mouseMove);
              bodyElement.removeEventListener('touchmove', mouseMove);
              bodyElement.removeEventListener('mouseup', mouseUp);
              bodyElement.removeEventListener('mouseleave', mouseUp);
              bodyElement.removeEventListener('touchend', mouseUp);
              bodyElement.removeEventListener('touchcancel', mouseUp);
              if (!moveOK) // still need to front the element
                setTimeout(_ => {
                  if (canvasFrame.parentNode)
                    canvasFrame.parentNode.appendChild(canvasFrame);
                });
            }
            bodyElement.addEventListener('mousemove', mouseMove);
            bodyElement.addEventListener('touchmove', mouseMove);
            bodyElement.addEventListener('mouseup', mouseUp);
            bodyElement.addEventListener('mouseleave', mouseUp);
            bodyElement.addEventListener('touchend', mouseUp);
            bodyElement.addEventListener('touchcancel', mouseUp);
          }
          newCanvasX += 25;
          newCanvasY += 25;
          schemeWidget.x = newCanvasX;
          schemeWidget.y = newCanvasY;
          schemeWidget.width = width;
          schemeWidget.height = height;
          schemeWidget.show();   // Not sure if this should happen by default, but for now...
          return schemeWidget;
        }

        defineGlobalSymbol("canvas-gfx-context", canvas_gfx_context, { dontInline: true, group: "web-gfx" });
        function canvas_gfx_context(schemeWidget) {
          let canvasRenderingContext = schemeWidget.canvas2dRenderingContext;
          return canvasRenderingContext;
        }

        defineGlobalSymbol("gfx-save", gfx_save, { evalArgs: 0, dontInline: true, group: "web-gfx" });
        function gfx_save(...forms) {
          let scope = this, canvasRenderingContext = scope[gfxContextAtom];
          canvasRenderingContext.save();
          try {
            let res = NIL;
            for (let form of forms)
              res = scope.eval(form);
            return res;
          } finally {
            canvasRenderingContext.restore();
          }
          return canvasRenderingContext;
        }

        defineGlobalSymbol("translate", translate, {dontInline: true, group: "web-gfx" });
        function translate(x, y) {
          let scope = this, canvasRenderingContext = scope[gfxContextAtom];
          canvasRenderingContext.translate(x, y);
          return canvasRenderingContext;
        }

        defineGlobalSymbol("scale", scale, { dontInline: true, group: "web-gfx" });
        function scale(width, height = width) {
          let scope = this, canvasRenderingContext = scope[gfxContextAtom];
          canvasRenderingContext.scale(width, height);
          return canvasRenderingContext;
        }

        defineGlobalSymbol("rotate", rotate, { dontInline: true, group: "web-gfx" });
        function rotate(theta) {
          let scope = this, canvasRenderingContext = scope[gfxContextAtom];
          canvasRenderingContext.rotate(theta);
          return canvasRenderingContext;
        }

        function CRCfunction(scope, fn) {
          let canvasRenderingContext = scope[gfxContextAtom];
          fn(canvasRenderingContext);
          return canvasRenderingContext;
        }

        function CRCProperty(property) {
          return function(newValue = undefined) {
            let canvasRenderingContext = this[gfxContextAtom];
            let value = canvasRenderingContext[property];
            if (newValue !== undefined)
              canvasRenderingContext[property] = newValue;
            return value;
          }
        }

        let commonOptions = { dontInline: true, group: "web-gfx" };  // XXX TODO: remove dontInline when draw2d has a compile hook

        defineGlobalSymbol("save-context", save_context, commonOptions);
        function save_context() { return CRCfunction(this, ctx => ctx.save()) }

        defineGlobalSymbol("restore-context", restore_context, commonOptions);
        function restore_context() { return CRCfunction(this, ctx => ctx.restore()) }

        defineGlobalSymbol("canvas-width", canvas_width, commonOptions);
        function canvas_width() {
          let ctx = this[gfxContextAtom];
          let schemeWidget = contextToSchemeWidget.get(ctx);
          return schemeWidget.width;
        };

        defineGlobalSymbol("canvas-height", canvas_height, commonOptions);
        function canvas_height() {
          let ctx = this[gfxContextAtom];
          let schemeWidget = contextToSchemeWidget.get(ctx);
          return schemeWidget.height;
        };

        defineGlobalSymbol("stash-point", stash_point, commonOptions);
        function stash_point(x, y) {
          let ctx = this[gfxContextAtom];
          let schemeWidget = contextToSchemeWidget.get(ctx);
          schemeWidget.stashX = x;
          schemeWidget.stashY = y;
        };

        defineGlobalSymbol("move-to-stashed", move_to_stashed, commonOptions);
        function move_to_stashed(x, y) {
          let ctx = this[gfxContextAtom];
          let schemeWidget = contextToSchemeWidget.get(ctx);
          if (schemeWidget.stashX !== undefined && schemeWidget.stashY !== undefined)
            ctx.moveTo(schemeWidget.stashX, schemeWidget.stashY);
        };

        defineGlobalSymbol("line-to-stashed", line_to_stashed, commonOptions);
        function line_to_stashed(x, y) {
          let ctx = this[gfxContextAtom];
          let schemeWidget = contextToSchemeWidget.get(ctx);
          if (schemeWidget.stashX !== undefined && schemeWidget.stashY !== undefined)
            ctx.lineTo(schemeWidget.stashX, schemeWidget.stashY);
        };

        defineGlobalSymbol("clear-canvas", clear_canvas, commonOptions);
        function clear_canvas() {
          let ctx = this[gfxContextAtom], canvas = ctx.canvas, width = canvas.width, height = canvas.height;
          ctx.save();
          if (clearColor) {
            ctx.fillStyle = clearColor;
            ctx.fillRect(0, 0, width, width);
          }
          ctx.clearRect(0, 0, width, height);
          ctx.restore();
        };

        defineGlobalSymbol("show-canvas", show_canvas, commonOptions);
        function show_canvas(x = optional, y = optional, width = optional, height = optional) {
          let ctx = this[gfxContextAtom], schemeWidget = contextToSchemeWidget.get(ctx);
          schemeWidget.show(x, y, width, height);
          return NIL;
        };

        defineGlobalSymbol("hide-canvas", hide_canvas, commonOptions);
        function hide_canvas() {
          let ctx = this[gfxContextAtom], schemeWidget = contextToSchemeWidget.get(ctx);
          schemeWidget.hide();
          return NIL;
        };

        defineGlobalSymbol("fill-rect", fill_rect, commonOptions);
        function fill_rect(x, y, width, height) { return CRCfunction(this, ctx => ctx.fillRect(x, y, width, height)) }
        
        defineGlobalSymbol("clear-rect", fill_rect, commonOptions);
        function clear_rect(x, y, width, height) { return CRCfunction(this, ctx => ctx.clearRect(x, y, width, height)) }
        
        defineGlobalSymbol("stroke-rect", stroke_rect, commonOptions);
        function stroke_rect(x, y, width, height) {
          return CRCfunction(this, ctx => ctx.strokeRect(x, y, width, height))
        }

        defineGlobalSymbol("fill-text", fill_text, commonOptions);
        function fill_text(text, x, y , maxWidth = optional) {
          return CRCfunction(this, ctx => ctx.fillText(text, x, y , maxWidth))
        }

        defineGlobalSymbol("measure-text", measure_text, commonOptions);
        function measure_text(text) { return CRCfunction(this, ctx => ctx.measureText(text)) }

        const line_width = CRCProperty("lineWidth");
        defineGlobalSymbol("line-width", line_width, commonOptions);

        const line_cap = CRCProperty("lineCap");
        defineGlobalSymbol("line-cap", line_cap, commonOptions);

        const line_join = CRCProperty("lineJoin");
        defineGlobalSymbol("line-join", line_join, commonOptions);

        const miter_limit = CRCProperty("miterLimit");
        defineGlobalSymbol("miter-limit", miter_limit, commonOptions);

        defineGlobalSymbol("get-line-dash", get_line_dash, commonOptions);
        function get_line_dash() { return CRCfunction(this, ctx => ctx.getLineDash) }

        defineGlobalSymbol("set-line-dash", set_line_dash, commonOptions);
        function set_line_dash(segments) { CRCfunction(this, ctx => ctx.setLineDash(segments)) }

        const line_dash_offset = CRCProperty("lineDashOffset");
        defineGlobalSymbol("line-dash-offset", line_dash_offset, commonOptions);
        
        const font = CRCProperty("font");
        defineGlobalSymbol("font", font, commonOptions);

        const text_align = CRCProperty("textAlign");
        defineGlobalSymbol("text-align", text_align, commonOptions);

        const text_baseline = CRCProperty("textBaseline");
        defineGlobalSymbol("text-baseline", text_baseline, commonOptions);

        const direction = CRCProperty("direction");
        defineGlobalSymbol("direction", direction, commonOptions);

        const fill_style = CRCProperty("fillStyle");
        defineGlobalSymbol("fill-style", fill_style, commonOptions);

        const stroke_style = CRCProperty("strokeStyle");
        defineGlobalSymbol("stroke-style", stroke_style, commonOptions);

        defineGlobalSymbol("create-conic-gradient", create_conic_gradient, commonOptions);
        function create_conic_gradient(startAngle, x, y) {
          return CRCfunction(this, ctx => ctx.createConicGradient(startAngle, x, y))
        }

        defineGlobalSymbol("create-linear-gradient", create_linear_gradient, commonOptions);
        function create_linear_gradient(x0, y0, x1, y1) {
          return CRCfunction(this, ctx => ctx.createLinearGradient(x0, y0, x1, y1))
        }

        defineGlobalSymbol("create-radial-gradient", create_radial_gradient, commonOptions);
        function create_radial_gradient(x0, y0, r0, x1, y1, r1) {
          return CRCfunction(this, ctx => ctx.createRadialGradient(x0, y0, r0, x1, y1, r1))
        }

        defineGlobalSymbol("create-pattern", create_pattern, commonOptions);
        function create_pattern(image, repetition) { CRCfunction(this, ctx => ctx.createPattern(image, repetition)) }

        const shadow_color = CRCProperty("shadowColor");
        defineGlobalSymbol("shadow-color", shadow_color, commonOptions);

        const shadow_offset_x = CRCProperty("shadowOffsetX");
        defineGlobalSymbol("shadow-offset-x", shadow_offset_x, commonOptions);

        const shadow_offset_y = CRCProperty("shadowOffsetY");
        defineGlobalSymbol("shadow-offset-y", shadow_offset_y, commonOptions);

        defineGlobalSymbol("begin-path", begin_path, commonOptions);
        function begin_path() { return CRCfunction(this, ctx => ctx.beginPath()) }

        defineGlobalSymbol("close-path", close_path, commonOptions);
        function close_path() { return CRCfunction(this, ctx => ctx.closePath()) }

        defineGlobalSymbol("move-to", move_to, commonOptions);
        function move_to(x, y) { return CRCfunction(this, ctx => ctx.moveTo(x, y)) }

        defineGlobalSymbol("line-to", line_to, commonOptions);
        function line_to(x, y) { return CRCfunction(this, ctx => ctx.lineTo(x, y)) }

        defineGlobalSymbol("bezier-curve-to", bezier_curve_to, commonOptions);
        function bezier_curve_to(cp1x, cp1y, cp2x, cp2y, x, y) {
          return CRCfunction(this, ctx => ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y))
        }

        defineGlobalSymbol("quadratic-curve-to", quadratic_curve_to, commonOptions);
        function quadratic_curve_to(cpx, cpy, x, y) {
          return CRCfunction(this, ctx => ctx.quadraticCurveTo(cpx, cpy, x, y))
        }

        defineGlobalSymbol("arc", arc, commonOptions);
        function arc(x, y, radius, startAngle, endAngle, counterclockwise = false) {
          return CRCfunction(this, ctx => ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise))
        }

        defineGlobalSymbol("arc-to", arc_to, commonOptions);
        function arc_to(x1, y1, x2, y2, radius) { return CRCfunction(this, ctx => ctx.arcTo(x1, y1, x2, y2, radius)) }

        defineGlobalSymbol("ellipse", ellipse, commonOptions);
        function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise = false) {
          return CRCfunction(this, ctx => ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise))
        }

        defineGlobalSymbol("rect", rect, commonOptions);
        function rect(x, y, width, height) { return CRCfunction(this, ctx => ctx.rect(x, y, width, height)) }

        defineGlobalSymbol("fill", fill, commonOptions);
        function fill(...params) { return CRCfunction(this, ctx => ctx.fill(...params)) }

        defineGlobalSymbol("stroke", stroke, commonOptions);
        function stroke(...params) { return CRCfunction(this, ctx => ctx.stroke(...params)) }

        defineGlobalSymbol("draw-focus-if-needed", draw_focus_if_needed, commonOptions);
        function draw_focus_if_needed(...params) { return CRCfunction(this, ctx => ctx.drawFocusIfNeeded(...params)) }

        defineGlobalSymbol("scroll-path-into-view", scroll_path_into_view, commonOptions);
        function scroll_path_into_view(...params) { return CRCfunction(this, ctx => ctx.scrollPathIntoView(...params)) }

        defineGlobalSymbol("is-point-in-path", is_point_in_path, commonOptions);
        function is_point_in_path(...params) { return CRCfunction(this, ctx => ctx.isPointInPath(...params)) }

        defineGlobalSymbol("is-point-in-stroke", is_point_in_stroke, commonOptions);
        function is_point_in_stroke(...params) { return CRCfunction(this, ctx => ctx.isPointInStroke(...params)) }

        defineGlobalSymbol("clip", clip, commonOptions);
        function clip(...params) { return CRCfunction(this, ctx => ctx.clip(...params)) }

        const global_alpha = CRCProperty("globalAlpha");
        defineGlobalSymbol("global-alpha", global_alpha, commonOptions);

        const global_composite_operation = CRCProperty("globalCompositeOperation");
        defineGlobalSymbol("global-composite-operation", global_composite_operation, commonOptions);

        defineGlobalSymbol("draw-image", draw_image, commonOptions);
        function draw_image(...params) { return CRCfunction(this, ctx => ctx.drawImage(...params)) }

        defineGlobalSymbol("createImageData", createImageData, commonOptions);
        function createImageData(...params) { return CRCfunction(this, ctx => ctx.createImageData(...params)) }

        defineGlobalSymbol("get-image-data", get_image_data, commonOptions);
        function get_image_data(sx, sy, sw, sh) { return CRCfunction(this, ctx => ctx.getImageData(sx, sy, sw, sh)) }

        defineGlobalSymbol("put-image-data", put_image_data, commonOptions);
        function put_image_data(...params) { return CRCfunction(this, ctx => ctx.putImageData(...params)) }

        const image_smoothing_enabled = CRCProperty("imageSmoothingEnabled");
        defineGlobalSymbol("image-smoothing-enabled", image_smoothing_enabled, commonOptions);

        const image_smoothing_quality = CRCProperty("imageSmoothingQuality");
        defineGlobalSymbol("image-smoothing-quality", image_smoothing_quality, commonOptions);
      }

      let printBoxElement;

      function handleInput(enterKey) {
        let parseContext = [], assignSyntax = true;
        let inputText = getElementText(inputElement);
        // console.log("TEXT", inputText);
        let pos = getSelectionPosition(inputElement);
        for (let span of inputElement.querySelectorAll('span'))
          span.replaceWith(span.textContent);
        inputElement.normalize();
        try {
          function* characterGenerator() {
            let part1 = inputText.substr(0, pos), part2 = inputText.substr(pos);

            // Feed parser part up to the cursor
            for (let ch of part1)
              yield ch;

            // Colorize opening grouping symbols
            let alpha = 1, fade = .6;
            for (let i = parseContext.length; i > 0; --i) {
              let tok = parseContext[i-1], pos = tok.position, width = 1;
              if (typeof tok.value === 'string') width = tok.value.length;
              colorizeCharsAt(inputElement, pos, width, 'match-tokens',
                `background-color: rgba(255, 200, 0, ${alpha}); color: blue`);
              alpha *= fade;
            }

            let depth = parseContext.length;
            alpha = 1;
            // Feed the rest
            for (let ch of part2) {
              yield ch;
              if (parseContext.length < depth) {
                let tok = parseContext.currentToken, pos = tok.position, width = 1;
                if (typeof tok.value === 'string') width = tok.value.length;
                if (tok.endPosition)
                  pos = tok.endPosition;
                if (tok.endWidth)
                  width = tok.endWidth;
                colorizeCharsAt(inputElement, pos, width, 'match-tokens',
                  `background-color: rgba(255, 200, 0, ${alpha}); color: blue;`);
                alpha *= fade;
                depth = parseContext.length;
              }
            }
            insertTextAndSetCursorAfter(inputElement, pos, "");
          }

          // Parse
          let expr = globalScope.parseSExpr(characterGenerator(), { parseContext, assignSyntax });

          if (!(enterKey && pos === inputText.length))
            return; // TODO: auto-indent the line-break

          let loadPath = null, loadLine = null;
          inputElement.textContent = '';
          ++varNo;
          showInput(inputText, loadPath, loadLine, expr, varNo);

          // Eval
          let value = globalScope.eval(expr, globalScope);

          // Show results and save in variables for later reuse
          showResult(value, varNo);
        } catch (error) {
          if (error instanceof SchemeParseError) {
            if (error instanceof SchemeSyntaxError) {
              let position = error.position;
              colorizeCharsAt(inputElement, position, inputText.length - position, 'error-tokens');
            }
            let indent = "";
            if (enterKey && parseContext.currentToken?.type !== 'string' && parseContext.length > 0)
              indent =  NBSP.repeat(parseContext[parseContext.length-1].lineChar + 2);
            insertTextAndSetCursorAfter(inputElement, pos, indent);
          } else {
            showError(error);
          }
        }
      }

      function showInput(inputText, path, line, expr, varNo) {
        // Show results and save in variables for later reuse
        inputText = trimEndNewlines(inputText);
        let div = createElement('div', 'input-box');
        if (varNo != null && expr !== undefined) {
          let name = `?${varNo}`;
          globalScope[Atom(name)] = expr;
          div.appendChild(createElement('span', 'tag', name));
        }
        let innerDiv = createElement('div', 'input-scroller');
        if (path != null)
          innerDiv.appendChild(createElement('div', 'load-path', `${path}, line ${line}:`));
        for (let pgf of convertToHTMLContent(inputText, 'text'))
          innerDiv.appendChild(pgf);
        div.appendChild(innerDiv);
        outputElement.appendChild(div);
        div.scrollIntoView();
      }

      function trimEndNewlines(str) {
        while (NL[str[str.length-1]])
          str = str.substr(0, str.length-1);
        return str;
      }

      function showResult(value, varNo) {
        if (printBoxElement)
          printBoxElement = undefined;
        let div = createElement('div', 'result-box');
        if (varNo != null) {
          let name = `=${varNo}`;
          globalScope[Atom(name)] = value;
          div.appendChild(createElement('span', 'tag', name));
        }
        let innerDiv = createElement('div', 'result-scroller');
        let evaluatedString = globalScope.string(value);
        for (let pgf of convertToHTMLContent(evaluatedString, 'text'))
          innerDiv.appendChild(pgf);
        div.appendChild(innerDiv);
        outputElement.appendChild(div);
        div.scrollIntoView();
      }

      function linePrinter(line) {
        if (!printBoxElement)
          printBoxElement = createElement('div', 'print-box');
        let innerDiv = createElement('div', 'print-scroller');
        for (let pgf of convertToHTMLContent(line+'\n', 'text'))
          innerDiv.appendChild(pgf);
        printBoxElement.appendChild(innerDiv);
        outputElement.appendChild(printBoxElement);
        printBoxElement.scrollIntoView();
      }

      function showError(error) {
        console.error("Error", error);
        let errorElement = createElement('div', 'error-box', String(error));
        outputElement.appendChild(errorElement)
        errorElement.scrollIntoView();
      }

      function convertToHTMLContent(text, cls) {
        let divs = [], line = '';
        for (let ch of text) {
          if (NL[ch]) {
            addDiv(line);
            line = '';
          }
          if (WS[ch])
            ch = NBSP;
          line += ch;
        }
        if (line !== '')
          addDiv(line);
        return divs;
        function addDiv(line) {
          let element = createElement('div', cls, line.replaceAll(' ', NBSP));
          if (line === '')
            element.appendChild(createElement('br'));
          divs.push(element);
        }
        return res;
      }

      function getSelectionPosition(editableElement) {
        let selection = window.getSelection();
        // console.log("SEL", selection.anchorNode, selection.anchorOffset, selection);
        if (!selection) return undefined;
        let anchorNode = selection.anchorNode;
        let selectionPosition = selection.anchorOffset;
        if (!editableElement.contains(anchorNode)) return undefined;
        traverseEditableElement(editableElement, onNode);
        // console.log("POS", selectionPosition);
        return selectionPosition;
        function onNode(node, pos, isNewline) {
          // console.log ("GSP", pos, node.tagName, node.data);
          if (node === anchorNode) {
            selectionPosition += pos;
            return true;
          }
        }
      }

      function getElementText(element) {
        let text = '';
        traverseEditableElement(element, onNode);
        // Parser recognizes NBSP as whitespace but know that they're there!
        // text = text.replaceAll(NBSP, ' ');
        // console.log("GET", text);
        return text;
        function onNode(node, pos, isNewline) {
          if (isNewline)
            text += '\n';
          if (node instanceof Text)
            text += node.data;
        }
      }

      function insertTextAndSetCursorAfter(element, insertPosition, text = '') {
        // console.log("ISC", insertPosition, text);
        let selection = window.getSelection();
        if (!selection) return false;
        return traverseEditableElement(element, onNode);
        function onNode(node, pos, isNewline) {
          let localPos = insertPosition - pos;
          // console.log ("ITA", localPos, node.tagName, node.data);
          if (localPos < 0) return;
          if (node instanceof Text) {
            // console.log ("ITA TEXT");
            let content = node.data;
            if (localPos <= node.data.length) {
              if (text !== '') {
                content = content.substr(0, localPos) + text + content.substr(localPos);
                node.textContent = data;
              }
              selection.collapse(node, localPos);
              return true;
            }
          } else if (node instanceof Element) {
            if (localPos < 0) return false;
            if (localPos === 0) {
              // console.log ("ITA ELEMENT");
              let textNode = document.createTextNode(text);
              if (node.tagName === 'BR' && node.parentElement.tagName === 'DIV') {
                node.replaceWith(textNode);
              } else {
                node.prepend(textNode);
                selection.collapse(textNode, text.length);
              }
              return true;
            }
          }
        }
      }

      function colorizeCharsAt(element, colorizePosition, nchar, cls, style) {
        // console.log("COLORIZE!", colorizePosition, nchar, cls, style);
        return traverseEditableElement(element, onNode);
        function onNode(node, pos, isNewline) {
          let localPos = colorizePosition - pos;
          // console.log("COLORIZE", localPos, node.tagName, node.data);
          if (localPos < 0) return;
          if (node instanceof Text) {
            let text = node.data;
            if (localPos < text.length) {
              let before, replace, after, n = nchar;
              if (n > text.length - localPos)
                n = text.length - localPos;
              if (localPos === 0) {
                replace = node;
                if (n < text.length)
                  after = node.splitText(n);
              } else {
                before = node;
                replace = node.splitText(localPos);
                if (n < replace.textContent.length)
                  after = replace.splitText(n);
              }
              let highlightElement = createElement('span', cls, replace.textContent);
              if (style)
                highlightElement.setAttribute('style', style);
              node.parentElement.replaceChild(highlightElement, replace);
              nchar -= n;
              colorizePosition += n;
              if (nchar <= 0) return true;
            }
          }
        }
      }

      function traverseEditableElement(editableElement, onNode) {
        let pos = 0;
        return traverse(editableElement);
        function traverse(node) {
          let isReturn = false;
          if (node.parentElement === editableElement && node.previousSibling && node.tagName === 'DIV') {
              pos += 1;
              isReturn = true;
          }
          if (node !== editableElement) {
            let res = onNode(node, pos, isReturn);
            if (res !== undefined) return res;
          }
          if (node instanceof Element) {
            for (let child of node.childNodes) {
              let res = traverse(child);
              if (res !== undefined) return res;
            }
          } else if (node instanceof Text) {
            pos += node.data.length;
          }
        }
      }

      function runUnitTests() {
        runTests();
        async function runTests() {
          let traceCompilerCode = true;
          let UnitTest = await(import("./UnitTest.mjs"));
          UnitTest.run({ throwOnError: false, traceCompilerCode });
        }
      }

      if ('serviceWorker' in navigator && window.location.protocol === 'https:')
        navigator.serviceWorker.register('service-worker.js');

      try { loadState(); } catch (e) {} // inconvenient to crash while loading
   </script>
  </body>
</html>